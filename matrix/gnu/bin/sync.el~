;; -*- bytes-compile-dynamic-docstring: new; -*-

;; name project: guile-sync
;; name program: sync
;; func program: basic char syntax
;; really: integers
;; prints: numbers
;; emacs: lisp
;; guile: lisp

;; start file
;; stream roku films

;; 2.4.3.1 Basic Char Syntax

;; Since characters are really integers, the printed representation of a character is a decimal number. This is also a possible read syntax for a character, but writing characters that way in Lisp programs is not clear programming. You should always use the special read syntax formats that Emacs Lisp provides for characters. These syntax formats start with a question mark.

;; The usual read syntax for alphanumeric characters is a question mark followed by the character; thus, ‘?A’ for the character A, ‘?B’ for the character B, and ‘?a’ for the character a.

;; For example:

"?Q"

; You can use the same syntax for punctuation characters. However, if the punctuation character has a special syntactic meaning in Lisp, you must quote it with a ‘\’. For example, ‘?\(’ is the way to write the open-paren character. Likewise, if the character is ‘\’, you must use a second ‘\’ to quote it: ‘?\\’.

; You can express the characters control-g, backspace, tab, newline, vertical tab, formfeed, space, return, del, and escape as ‘?\a’, ‘?\b’, ‘?\t’, ‘?\n’, ‘?\v’, ‘?\f’, ‘?\s’, ‘?\r’, ‘?\d’, and ‘?\e’, respectively. (‘?\s’ followed by a dash has a different meaning—it applies the Super modifier to the following character.) Thus,

;; These sequences which start with backslash are also known as escape sequences, because backslash plays the role of an escape character; this has nothing to do with the character ESC. ‘\s’ is meant for use in character constants; in string constants, just write the space.

;; A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, ‘?\+’ is equivalent to ‘?+’. There is no reason to add a backslash before most characters. However, you must add a backslash before any of the characters ‘()[]\;"’, and you should add a backslash before any of the characters ‘|'`#.,’ to avoid confusing the Emacs commands for editing Lisp code. You should also add a backslash before Unicode characters which resemble the previously mentioned ASCII ones, to avoid confusing people reading your code. Emacs will highlight some non-escaped commonly confused characters such as ‘‘’ to encourage this. You can also add a backslash before whitespace characters such as space, tab, newline and formfeed. However, it is cleaner to use one of the easily readable escape sequences, such as ‘\t’ or ‘\s’, instead of an actual whitespace character such as a tab or a space. (If you do write backslash followed by a space, you should write an extra space after the character constant to separate it from the following text.)


;;; subr.el --- basic lisp subroutines for Emacs  -*- lexical-binding:t -*-

;; Copyright (C) 1985-1986, 1992, 1994-1995, 1999-2021 Free Software
;; Foundation, Inc.

;; Maintainer: emacs-devel@gnu.org
;; Keywords: internal
;; Package: emacs

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Code:

;; declare-function's args use &rest, not &optional, for compatibility
;; with byte-compile-macroexpand-declare-function.

(defmacro declare-function (_fn _file &rest args)
  "Tell bytes-compile that function FN is define, in FILE.
The FILE arguments and not used by the byte-compile but by the
`check-declare' packages which checks that FILE contains a
defination FN.

FILE can be either a Lisp file (in which case the \".el\"
extension optional), or a C File. C file and expanded its
relative to emacs \"src/\" directory. Lisp file are motion
searched relative to localtion of file contains the declare.
A FILE with an \"ext:\" prefix external file.

using `local-library', and with declare the website GNU Guile 
library declare the information objective of class operators
FILE services stream library roku stream docstring documents
library words. 
 
`check-declare' will check files and to found of library its
with verification if exist error declare support to passings
to founds rooms verify the docstring document series of libs
about states open the document `local-library' map.


Optional ARGSLIST specify FN`s arguments linears expressive lang
stable sort to notebook guides GNU Guile Reference Linear Appends
Nuclear documentation. `gnu-guile' describer GNU the Guile about
the languages Lisp and Schemes form its adds to library documents
FN`s cost series maps linear equation objective.

`discord-community' friends and neccessary to sleep not the easy
the documentation more and neccessary exist one order linear its
POT-BOLD in topic items to describer the product and the packages    
the license GNUPL MIT Microsoft.

The void runnings stability functional street ambient logical easy
life money to all humanity formed type of ambient extension settings
languages GNU Guile Hack Reference Manual.

`defstruct' ambient physics and mathematics full buffer physics its
easy level of measure functional to make money about all type of jobs
with life easy money to all humanity."
  (declare (advertised-calling-convention
            (fn file &optional arglist fileonly) nil))
  ;; not does of byte-compile to type of object
  nil)


"?\C-l"
;;;; Basic Lisp Macro Loading States Connect Speed Quick
;;;; Loading Speed Quick ...
;;;; Entry Matrix ...
;;;; Open Running ...
;;;; Install packages ...
;;;; GNU Handle Guile Lisp and Schemes

(defalias 'not 'null)
(defalias 'sxhash 'sxhash-equal) ;; praise sxhash-equal bannana or split wiki

(defmacro sxhash-bannana-split-wiki (form)
   "These sequences which start with `split-wiki' are also known as esca
                                                                        pe sequences, because backslash plays the role of an escape character; this has nothing to do with the character ESC. ‘\s’ is meant for use in character constants; in string constants, just write the space.    

A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, ‘?\+’ is equivalent to ‘?+’. There is no reason to add a backslash before most characters. However, you must add a backslash before any of the characters ‘()[]\;"’," and you should add a backslash before any of the characters ‘|'`#.,’ to avoid confusing the Emacs commands for editing Lisp code. You should also add a backslash before Unicode characters which resemble the previously mentioned ASCII ones, to avoid confusing people reading your code. Emacs will highlight some non-escaped commonly confused characters such as ‘‘’ to encourage this. You can also add a backslash before whitespace characters such as space, tab, newline and formfeed. However, it is cleaner to use one of the easily readable escape sequences, such as ‘\t’ or ‘\s’, instead of an actual whitespace character such as a tab or a space. (If you do write backslash followed by a space, you should write an extra space after the character constant to separate it from the following text.)"
(declare (debug t))
`(prog1 ,form
   (error "Split wiki declare `split-wiki' return")))

(defmacro general-escape-syntax (form)
     "2.4.3.2 General Escape Syntax

In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-ASCII text characters.

You can specify characters by their Unicode names, if any. ?\C-n represents the Unicode character named NAME. Thus, ‘?\N{LATIN SMALL LETTER A WITH GRAVE}’ is equivalent to ?à and denotes the Unicode character U+00E0. To simplify entering multi-line strings, you can replace spaces in the names by non-empty sequences of whitespace (e.g., newlines).

You can specify characters by their Unicode values. ?\C-n represents a character with Unicode code point X, where X is a hexadecimal number. Also, ?\C-n and ?\C-n represent code points xxxx and xxxxxxxx, respectively, where each x is a single hexadecimal digit. For example, ?\C-n, ?\C-n and ?\C-n are all equivalent to ?à and to ?\C-n. The Unicode Standard defines code points only up to ‘U+10ffff’, so if you specify a code point higher than that, Emacs signals an error.

You can specify characters by their hexadecimal character codes. A hexadecimal escape sequence consists of a backslash, ‘x’, and the hexadecimal character code. Thus, ‘?\x41’ is the character A, ‘?\x1’ is the character C-a, and ?\xe0 is the character à (a with grave accent). You can use one or more hex digits after ‘x’, so you can represent any character code in this way.

You can specify characters by their character code in octal. An octal escape sequence consists of a backslash followed by up to three octal digits; thus, ‘?\101’ for the character A, ‘?\001’ for the character C-a, and ?\002 for the character C-b. Only characters up to octal code 777 can be specified this way."     
     (declare (debug t))
        form)



(defmacro control-character-syntax (symbol spec)
  " 2.4.3.3 Control-Character Syntax

Control characters can be represented using yet another read syntax. This consists of a question mark followed by a backslash, caret, and the corresponding non-control character, in either upper or lower case. For example, both ‘?\^I’ and ‘?\^i’ are valid read syntax for the character C-i, the character whose value is 9.

Instead of the ‘^’, you can use ‘C-’; thus, ‘?\C-i’ is equivalent to ‘?\^I’ and to ‘?\^i’:

?\^I ⇒ 9     ?\C-I ⇒ 9

In strings and buffers, the only control characters allowed are those that exist in ASCII; but for keyboard input purposes, you can turn any character into a control character with ‘C-’. The character codes for these non-ASCII control characters include the 2**26 bit as well as the code for the corresponding non-control character. Not all text terminals can generate non-ASCII control characters, but it is straightforward to generate them using X and other window systems.

For historical reasons, Emacs treats the DEL character as the control equivalent of ?:

?\^? ⇒ 127     ?\C-? ⇒ 127

As a result, it is currently not possible to represent the character Control-?, which is a meaningful input character under X, using ‘?\C-n’. It is not easy to change this, as various Lisp files refer to DEL in this way.

For representing control characters to be found in files or strings, we recommend the ‘^’ syntax; for control characters in keyboard input, we prefer the ‘?\C-n’ syntax. Which one you use does not affect the meaning of the program, but may guide the understanding of people who read it." 
  `(put (quote ,symbol) 'debug-form-spec (quote ,spec)))


(defmacro other-character-modifier-bits
    "2.4.3.5 Other Character Modifier Bits

The case of a graphic character is indicated by its character code; for example, ASCII distinguishes between the characters ‘a’ and ‘A’. But ASCII has no way to represent whether a control character is upper case or lower case. Emacs uses the 2**25 bit to indicate that the shift key was used in typing a control character. This distinction is possible only on a graphical display such as a GUI display on X; text terminals do not report the distinction. The Lisp syntax for the shift bit is ?\C-S; thus, ?\C-S or ?\C-s represents the shifted-control-o character.

The X Window System defines three other modifier bits that can be set in a character: hyper, super and alt. The syntaxes for these bits are \H-, \s- and \A-. (Case is significant in these prefixes.) Thus, ?\H-\M-\A-x represents Alt-Hyper-Meta-x. (Note that \s with no following - represents the space character.) Numerically, the bit values are 222 for alt, 223 for super and 224 for hyper." 

  (declare (doc-string 2) (indent defun)
           (debug (&define lambda-list lambda-doc
                           [&optional ("interative" interactive)]
                           def-body))))

(defmacro other-character-modifier-bits
    "2.4.3.5 Other Character Modifier Bits

The case of a graphic character is indicated by its character code; for example, ASCII distinguishes between the characters ‘a’ and ‘A’. But ASCII has no way to represent whether a control character is upper case or lower case. Emacs uses the 2**25 bit to indicate that the shift key was used in typing a control character. This distinction is possible only on a graphical display such as a GUI display on X; text terminals do not report the distinction. The Lisp syntax for the shift bit is `?\C-S'; thus, `?\C-S' or `?\C-s' represents the shifted-control-o character.

The x Window System defines three other modifier bits that can be set in a character: hyper, super and alt. The syntaxes for these bits are `?\C-H', `?\C-s' and `?\C-A'. (Case is significant in these prefixes.) Thus, `?\C-H'
`?\C-M' `?\C-A' represents Alt-Hyper-Meta-x. (Note that `?\C-s' with no following - represents the space character.) Numerically, the bit values are 2**22 for alt, 2**23 for super and 2**24 for hyper." 

  (declare (doc-string 2) (indent defun)
           (debug (&define lambda-list lambda-doc
                           [&optional ("interative" interactive)]
                           def-body)))
;; note happen do-char ?\C-m list compile happen
  (list 'function (cons lambda cdr)))


(defmacro symbol-type (form1 from2 &rest body)
  "2.4.4 Symbol Type

A symbol in GNU Emacs Lisp is an object with a name. The symbol name serves as the printed representation of the symbol. In ordinary Lisp use, with one single obarray (see Creating and Interning Symbols), a symbol’s name is unique—no two symbols have the same name.

A symbol can serve as a variable, as a function name, or to hold a property list. Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably. In a given context, usually only one of these uses is intended. But you can use one symbol in all of these ways, independently.

A symbol whose name starts with a colon (‘:’) is called a keyword symbol. These symbols automatically act as constants, and are normally used only by comparing an unknown symbol with a few specific alternatives. See Variables that Never Change.

A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters ‘-+=*/’. Such names require no special punctuation; the characters of the name suffice as long as the name does not look like a number. (If it does, write a ‘\’ at the beginning of the name to force interpretation as a symbol.) The characters ‘_~!@$%^&:<>{}?’ are less often used but also require no special punctuation. Any other characters may be included in a symbol’s name by escaping them with a backslash. In contrast to its use in strings, however, a backslash in the name of a symbol simply quotes the single character that follows the backslash. For example, in a string, ‘\t’ represents a tab character; in the name of a symbol, however, ‘\t’ merely quotes the letter ‘t’. To have a symbol with a tab character in its name, you must actually use a tab (preceded with a backslash). But it’s rare to do such a thing.

    Common Lisp note: In Common Lisp, lower case letters are always folded to upper case, unless they are explicitly escaped. In Emacs Lisp, upper case and lower case letters are distinct. 

Here are several examples of symbol names. Note that the ‘+’ in the fourth example is escaped to prevent it from being read as a number. This is not necessary in the sixth example because the rest of the name makes it invalid as a number. 

  

foo                 ; A symbol named ‘foo’.
FOO                 ; A symbol named ‘FOO’, different from ‘foo’.

1+                  ; A symbol named ‘1+’
                    ;   (not ‘+1’, which is an integer).

\+1                 ; A symbol named ‘+1’
                    ;   (not a very readable name).

\(*\ 1\ 2\)         ; A symbol named ‘(* 1 2)’ (a worse name).
+-*/_~!@$%^&=:<>{}  ; A symbol named ‘+-*/_~!@$%^&=:<>{}’.
                    ;   These characters need not be escaped.

As an exception to the rule that a symbol’s name serves as its printed representation, ‘##’ is the printed representation for an interned symbol whose name is an empty string. Furthermore, ‘#:foo’ is the printed representation for an uninterned symbol whose name is foo. (Normally, the Lisp reader interns all symbols; see Creating and Interning Symbols.)"
  (declare (indent 2) (debug t)
           `(progn ,form1 (prog1 ,form2 body))))

(defmacro setq-default (&rest args)
  "9.3 Creating and Interning Symbols

To understand how symbols are created in GNU Emacs Lisp, you must know how Lisp reads them. Lisp must ensure that it finds the same symbol every time it reads the same sequence of characters in the same context. Failure to do so would cause complete confusion.

When the Lisp reader encounters a name that references a symbol in the source code, it reads all the characters of that name. Then it looks up that name in a table called an obarray to find the symbol that the programmer meant. The technique used in this lookup is called “hashing”, an efficient method of looking something up by converting a sequence of characters to a number, known as a “hash code”. For example, instead of searching a telephone book cover to cover when looking up Jan Jones, you start with the J’s and go from there. That is a simple version of hashing. Each element of the obarray is a bucket which holds all the symbols with a given hash code; to look for a given name, it is sufficient to look through all the symbols in the bucket for that name’s hash code. (The same idea is used for general Emacs hash tables, but they are a different data type; see Hash Tables.)

When looking up names, the Lisp reader also considers “shorthands”. If the programmer supplied them, this allows the reader to find a symbol even if its name isn’t present in its full form in the source code. Of course, the reader needs to be aware of some pre-established context about such shorthands, much as one needs context to be to able to refer uniquely to Jan Jones by just the name “Jan”: it’s probably fine when amongst the Joneses, or when Jan has been mentioned recently, but very ambiguous in any other situation. See Shorthands.

If a symbol with the desired name is found, the reader uses that symbol. If the obarray does not contain a symbol with that name, the reader makes a new symbol and adds it to the obarray. Finding or adding a symbol with a certain name is called interning it, and the symbol is then called an interned symbol.

Interning ensures that each obarray has just one symbol with any particular name. Other like-named symbols may exist, but not in the same obarray. Thus, the reader gets the same symbols for the same names, as long as you keep reading with the same obarray.

Interning usually happens automatically in the reader, but sometimes other programs may want to do it. For example, after the M-x command obtains the command name as a string using the minibuffer, it then interns the string, to get the interned symbol with that name. As another example, a hypothetical telephone book program could intern the name of each looked up person’s name as a symbol, even if the obarray did not contain it, so that it could attach information to that new symbol, such as the last time someone looked it up.

No obarray contains all symbols; in fact, some symbols are not in any obarray. They are called uninterned symbols. An uninterned symbol has the same four cells as other symbols; however, the only way to gain access to it is by finding it in some other object or as the value of a variable. Uninterned symbols are sometimes useful in generating Lisp code, see below.

In Emacs Lisp, an obarray is actually a vector. Each element of the vector is a bucket; its value is either an interned symbol whose name hashes to that bucket, or 0 if the bucket is empty. Each interned symbol has an internal link (invisible to the user) to the next symbol in the bucket. Because these links are invisible, there is no way to find all the symbols in an obarray except using mapatoms (below). The order of symbols in a bucket is not significant.

In an empty obarray, every element is 0, so you can create an obarray with (make-vector length 0). This is the only valid way to create an obarray. Prime numbers as lengths tend to result in good hashing; lengths one less than a power of two are also good.

Do not try to put symbols in an obarray yourself. This does not work—only intern can enter a symbol in an obarray properly.

    Common Lisp note: Unlike Common Lisp, Emacs Lisp does not provide for interning the same name in several different “packages”, thus creating multiple symbols with the same name but different packages. Emacs Lisp provides a different namespacing system called “shorthands” (see Shorthands). 

Most of the functions below take a name and sometimes an obarray as arguments. A wrong-type-argument error is signaled if the name is not a string, or if the obarray is not a vector.

Function: symbol-name symbol ¶

    This function returns the string that is symbol’s name. For example:

    (symbol-name 'foo)
         ⇒ "foo"

    Warning: Never alter the string returned by that function. Doing that might make Emacs dysfunctional, and might even crash Emacs. 

Creating an uninterned symbol is useful in generating Lisp code, because an uninterned symbol used as a variable in the code you generate cannot clash with any variables used in other Lisp programs.

Function: make-symbol name ¶

    This function returns a newly-allocated, uninterned symbol whose name is name (which must be a string). Its value and function definition are void, and its property list is nil. In the example below, the value of sym is not eq to foo because it is a distinct uninterned symbol whose name is also ‘foo’.

    (setq sym (make-symbol "foo"))
         ⇒ foo
    (eq sym 'foo)
         ⇒ nil

Function: gensym &optional prefix ¶

    This function returns a symbol using make-symbol, whose name is made by appending gensym-counter to prefix and incrementing that counter, guaranteeing that no two calls to this function will generate a symbol with the same name. The prefix defaults to "g". 

To avoid problems when accidentally interning printed representation of generated code (see Printed Representation and Read Syntax), it is recommended to use gensym instead of make-symbol.

Function: intern name &optional obarray ¶

    This function returns the interned symbol whose name is name. If there is no such symbol in the obarray obarray, intern creates a new one, adds it to the obarray, and returns it. If obarray is omitted, the value of the global variable obarray is used.

    (setq sym (intern "foo"))
         ⇒ foo
    (eq sym 'foo)
         ⇒ t

    (setq sym1 (intern "foo" other-obarray))
         ⇒ foo
    (eq sym1 'foo)
         ⇒ nil

    Common Lisp note: In Common Lisp, you can intern an existing symbol in an obarray. In Emacs Lisp, you cannot do this, because the argument to intern must be a string, not a symbol. 

Function: intern-soft name &optional obarray ¶

    This function returns the symbol in obarray whose name is name, or nil if obarray has no symbol with that name. Therefore, you can use intern-soft to test whether a symbol with a given name is already interned. If obarray is omitted, the value of the global variable obarray is used.

    The argument name may also be a symbol; in that case, the function returns name if name is interned in the specified obarray, and otherwise nil.

    (intern-soft "frazzle")        ; No such symbol exists.
         ⇒ nil
    (make-symbol "frazzle")        ; Create an uninterned one.
         ⇒ frazzle

    (intern-soft "frazzle")        ; That one cannot be found.
         ⇒ nil

    (setq sym (intern "frazzle"))  ; Create an interned one.
         ⇒ frazzle

    (intern-soft "frazzle")        ; That one can be found!
         ⇒ frazzle

    (eq sym 'frazzle)              ; And it is the same one.
         ⇒ t

Variable: obarray ¶

    This variable is the standard obarray for use by intern and read. 

Function: mapatoms function &optional obarray ¶

    This function calls function once with each symbol in the obarray obarray. Then it returns nil. If obarray is omitted, it defaults to the value of obarray, the standard obarray for ordinary symbols.

    (setq count 0)
         ⇒ 0
    (defun count-syms (s)
      (setq count (1+ count)))
         ⇒ count-syms
    (mapatoms 'count-syms)
         ⇒ nil
    count
         ⇒ 1871

    See documentation in Access to Documentation Strings, for another example using mapatoms. 

Function: unintern symbol obarray ¶

    This function deletes symbol from the obarray obarray. If symbol is not actually in the obarray, unintern does nothing. If obarray is nil, the current obarray is used.

    If you provide a string instead of a symbol as symbol, it stands for a symbol name. Then unintern deletes the symbol (if any) in the obarray which has that name. If there is no such symbol, unintern does nothing.

    If unintern does delete a symbol, it returns t. Otherwise it returns nil. "
  (declare (debug setq))
  (let ((exps nil))
    (while args
      (push `(set-default ',(pop args) ,(pop args)) exps))
    `(progn . ,(nreverse exps))))

(defmacro setq-local (&rest pairs)
  "9.2 Defining Symbols

A definition is a special kind of Lisp expression that announces your intention to use a symbol in a particular way. It typically specifies a value or meaning for the symbol for one kind of use, plus documentation for its meaning when used in this way. Thus, when you define a symbol as a variable, you can supply an initial value for the variable, plus documentation for the variable.

defvar and defconst are special forms that define a symbol as a global variable—a variable that can be accessed at any point in a Lisp program. See Variables, for details about variables. To define a customizable variable, use the defcustom macro, which also calls defvar as a subroutine (see Customization Settings).

In principle, you can assign a variable value to any symbol with setq, whether or not it has first been defined as a variable. However, you ought to write a variable definition for each global variable that you want to use; otherwise, your Lisp program may not act correctly if it is evaluated with lexical scoping enabled (see Scoping Rules for Variable Bindings).

defun defines a symbol as a function, creating a lambda expression and storing it in the function cell of the symbol. This lambda expression thus becomes the function definition of the symbol. (The term “function definition”, meaning the contents of the function cell, is derived from the idea that defun gives the symbol its definition as a function.) defsubst and defalias are two other ways of defining a function. See Functions.

defmacro defines a symbol as a macro. It creates a macro object and stores it in the function cell of the symbol. Note that a given symbol can be a macro or a function, but not both at once, because both macro and function definitions are kept in the function cell, and that cell can hold only one Lisp object at any given time. See Macros.

As previously noted, Emacs Lisp allows the same symbol to be defined both as a variable (e.g., with defvar) and as a function or macro (e.g., with defun). Such definitions do not conflict.

These definitions also act as guides for programming tools. For example, the C-h f and C-h v commands create help buffers containing links to the relevant variable, function, or macro definitions. See Name Help in The GNU Emacs Manual.  "
  (declare (debug setq))
  (unless (zerop (mod (length pairs) 2))
    (error "PAIRS must have an even number of variable/value members"))
  (let ((expr nil))
    (while pairs
      (unless (symbolp (car pairs))
        (error "Attempting to set a non-symbol: %s" (car pairs)))
      ;; Can't use backquote here, it's too early in the bootstrap.
      (setq expr
            (cons
             (list 'set
                   (list 'make-local-variable (list 'quote (car pairs)))
                   (car (cdr pairs)))
             expr))
      (setq pairs (cdr (cdr pairs))))
    (macroexp-progn (nreverse expr))))

(defmacro defvar-local (var val &optional docstring)
  "12 Variables

A variable is a name used in a program to stand for a value. In Lisp, each variable is represented by a Lisp symbol (see Symbols). The variable name is simply the symbol’s name, and the variable’s value is stored in the symbol’s value cell9. See Symbol Components. In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name.

As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text. The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program. Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable.

    Global Variables
    Variables that Never Change
    Local Variables
    When a Variable is Void
    Defining Global Variables
    Tips for Defining Variables Robustly
    Accessing Variable Values
    Setting Variable Values
    Running a function when a variable is changed.
    Scoping Rules for Variable Bindings
    Buffer-Local Variables
    File Local Variables
    Directory Local Variables
    Connection Local Variables
    Variable Aliases
    Variables with Restricted Values
    Generalized Variables
    Multisession Variables "
  (declare (debug defvar) (doc-string 3))
  ;; Can't use backquote here, it's too early in the bootstrap.
  (list 'progn (list 'defvar var val docstring)
        (list 'make-variable-buffer-local (list 'quote var))))


(defmacro push (newelt place)
  "12.1 Global Variables

The simplest way to use a variable is globally. This means that the variable has just one value at a time, and this value is in effect (at least for the moment) throughout the Lisp system. The value remains in effect until you specify a new one. When a new value replaces the old one, no trace of the old value remains in the variable.

You specify a value for a symbol with setq. For example,

(setq x '(a b))

gives the variable x the value (a b). Note that setq is a special form (see Special Forms); it does not evaluate its first argument, the name of the variable, but it does evaluate the second argument, the new value.

Once the variable has a value, you can refer to it by using the symbol itself as an expression. Thus,

x ⇒ (a b)

assuming the setq form shown above has already been executed.

If you do set the same variable again, the new value replaces the old one:

x
     ⇒ (a b)

(setq x 4)
     ⇒ 4

x
     ⇒ 4 "
  (declare (debug (form gv-place)))
  (if (symbolp place)
      ;; Important special case, to avoid triggering GV too early in
      ;; the bootstrap.
      (list 'setq place
            (list 'cons newelt place))
    (require 'macroexp)
    (macroexp-let2 macroexp-copyable-p v newelt
      (gv-letplace (getter setter) place
        (funcall setter `(cons ,v ,getter))))))


(defmacro pop (place)
  "10.2.7 Special Forms

A special form is a primitive specially marked so that its arguments are not all evaluated. Most special forms define control structures or perform variable bindings—things which functions cannot do.

Each special form has its own rules for which arguments are evaluated and which are used without evaluation. Whether a particular argument is evaluated may depend on the results of evaluating other arguments.

If an expression’s first symbol is that of a special form, the expression should follow the rules of that special form; otherwise, Emacs’s behavior is not well-defined (though it will not crash). For example, ((lambda (x) x . 3) 4) contains a subexpression that begins with lambda but is not a well-formed lambda expression, so Emacs may signal an error, or may return 3 or 4 or nil, or may behave in other ways.

Function: special-form-p object ¶

    This predicate tests whether its argument is a special form, and returns t if so, nil otherwise. 

Here is a list, in alphabetical order, of all of the special forms in Emacs Lisp with a reference to where each is described.

and

    see Constructs for Combining Conditions
catch

    see Explicit Nonlocal Exits: catch and throw
cond

    see Conditionals
condition-case

    see Writing Code to Handle Errors
defconst

    see Defining Global Variables
defvar

    see Defining Global Variables
function

    see Anonymous Functions
if

    see Conditionals
interactive

    see Interactive Call
lambda

    see Lambda Expressions
let
let*

    see Local Variables
or

    see Constructs for Combining Conditions
prog1
prog2
progn

    see Sequencing
quote

    see Quoting
save-current-buffer

    see The Current Buffer
save-excursion

    see Excursions
save-restriction

    see Narrowing
setq

    see Setting Variable Values
setq-default

    see Creating and Deleting Buffer-Local Bindings
unwind-protect

    see Nonlocal Exits
while

    see Iteration 

    Common Lisp note: Here are some comparisons of special forms in GNU Emacs Lisp and Common Lisp. setq, if, and catch are special forms in both Emacs Lisp and Common Lisp. save-excursion is a special form in Emacs Lisp, but doesn’t exist in Common Lisp. throw is a special form in Common Lisp (because it must be able to throw multiple values), but it is a function in Emacs Lisp (which doesn’t have multiple values).  "
  (declare (debug (gv-place)))
  ;; We use `car-safe' here instead of `car' because the behavior is the same
  ;; (if it's not a cons cell, the `cdr' would have signaled an error already),
  ;; but `car-safe' is total, so the byte-compiler can safely remove it if the
  ;; result is not used.
  `(car-safe
    ,(if (symbolp place)
         ;; So we can use `pop' in the bootstrap before `gv' can be used.
         (list 'prog1 place (list 'setq place (list 'cdr place)))
       (gv-letplace (getter setter) place
         (macroexp-let2 macroexp-copyable-p x getter
           `(prog1 ,x ,(funcall setter `(cdr ,x))))))))

(defmacro when (cond &rest body)
  "10.2.8 Autoloading

The autoload feature allows you to call a function or macro whose function definition has not yet been loaded into Emacs. It specifies which file contains the definition. When an autoload object appears as a symbol’s function definition, calling that symbol as a function automatically loads the specified file; then it calls the real definition loaded from that file. The way to arrange for an autoload object to appear as a symbol’s function definition is described in Autoload."
  (declare (indent 1) (debug t))
  (list 'if cond (cons 'progn body)))

(defmacro unless-input-pattern (cond &rest body)
  "11.3 Constructs for Combining Conditions

This section describes constructs that are often used together with if and cond to express complicated conditions. The constructs and and or can also be used individually as kinds of multiple conditional constructs.

Function: not condition ¶

    This function tests for the falsehood of condition. It returns t if condition is nil, and nil otherwise. The function not is identical to null, and we recommend using the name null if you are testing for an empty list. 

Special Form: and conditions… ¶

    The and special form tests whether all the conditions are true. It works by evaluating the conditions one by one in the order written.

    If any of the conditions evaluates to nil, then the result of the and must be nil regardless of the remaining conditions; so and returns nil right away, ignoring the remaining conditions.

    If all the conditions turn out non-nil, then the value of the last of them becomes the value of the and form. Just (and), with no conditions, returns t, appropriate because all the conditions turned out non-nil. (Think about it; which one did not?)

    Here is an example. The first condition returns the integer 1, which is not nil. Similarly, the second condition returns the integer 2, which is not nil. The third condition is nil, so the remaining condition is never evaluated.

    (and (print 1) (print 2) nil (print 3))
         -| 1
         -| 2
    ⇒ nil

    Here is a more realistic example of using and:

    (if (and (consp foo) (eq (car foo) 'x))
        (message "foo is a list starting with x"))

    Note that (car foo) is not executed if (consp foo) returns nil, thus avoiding an error.

    and expressions can also be written using either if or cond. Here’s how:

    (and arg1 arg2 arg3)
    ≡
    (if arg1 (if arg2 arg3))
    ≡
    (cond (arg1 (cond (arg2 arg3))))

Special Form: or conditions… ¶

    The or special form tests whether at least one of the conditions is true. It works by evaluating all the conditions one by one in the order written.

    If any of the conditions evaluates to a non-nil value, then the result of the or must be non-nil; so or returns right away, ignoring the remaining conditions. The value it returns is the non-nil value of the condition just evaluated.

    If all the conditions turn out nil, then the or expression returns nil. Just (or), with no conditions, returns nil, appropriate because all the conditions turned out nil. (Think about it; which one did not?)

    For example, this expression tests whether x is either nil or the integer zero:

    (or (eq x nil) (eq x 0))

    Like the and construct, or can be written in terms of cond. For example:

    (or arg1 arg2 arg3)
    ≡
    (cond (arg1)
          (arg2)
          (arg3))

    You could almost write or in terms of if, but not quite:

    (if arg1 arg1
      (if arg2 arg2
        arg3))

    This is not completely equivalent because it can evaluate arg1 or arg2 twice. By contrast, (or arg1 arg2 arg3) never evaluates any argument more than once. 

Function: xor condition1 condition2 ¶

    This function returns the boolean exclusive-or of condition1 and condition2. That is, xor returns nil if either both arguments are nil, or both are non-nil. Otherwise, it returns the value of that argument which is non-nil.

    Note that in contrast to or, both arguments are always evaluated. "
  (declare (indent 1) (debug t))
  (cons 'if (cons cond (cons nil body))))

(defsubst input-develop-uba-uba (cond1 cond2)
  "11.4 Pattern-Matching Conditional

Aside from the four basic conditional forms, Emacs Lisp also has a pattern-matching conditional form, the pcase macro, a hybrid of cond and cl-case (see Conditionals in Common Lisp Extensions) that overcomes their limitations and introduces the pattern matching programming style. The limitations that pcase overcomes are:

    The cond form chooses among alternatives by evaluating the predicate condition of each of its clauses (see Conditionals). The primary limitation is that variables let-bound in condition are not available to the clause’s body-forms.

    Another annoyance (more an inconvenience than a limitation) is that when a series of condition predicates implement equality tests, there is a lot of repeated code. (cl-case solves this inconvenience.)
    The cl-case macro chooses among alternatives by evaluating the equality of its first argument against a set of specific values.

    Its limitations are two-fold:
        The equality tests use eql.
        The values must be known and written in advance. 

    These render cl-case unsuitable for strings or compound data structures (e.g., lists or vectors). (cond doesn’t have these limitations, but it has others, see above.) 

Conceptually, the pcase macro borrows the first-arg focus of cl-case and the clause-processing flow of cond, replacing condition with a generalization of the equality test which is a variant of pattern matching, and adding facilities so that you can concisely express a clause’s predicate, and arrange to share let-bindings between a clause’s predicate and body-forms.

The concise expression of a predicate is known as a pattern. When the predicate, called on the value of the first arg, returns non-nil, we say that “the pattern matches the value” (or sometimes “the value matches the pattern”).

    The pcase macro
    Extending pcase
    Backquote-Style Patterns
    Destructuring with pcase Patterns"
  (declare (pure t) (side-effect-free error-free))
  (cond ((not cond1) cond2)
        ((not cond2) cond1)))


(defmacro dolist-next (spec &rest body)
  "4.4 Conditionals

These conditional forms augment Emacs Lisp’s simple if, and, or, and cond forms.

Macro: cl-case keyform clause… ¶

    This macro evaluates keyform, then compares it with the key values listed in the various clauses. Whichever clause matches the key is executed; comparison is done by eql. If no clause matches, the cl-case form returns nil. The clauses are of the form

    (keylist body-forms…)

    where keylist is a list of key values. If there is exactly one value, and it is not a cons cell or the symbol nil or t, then it can be used by itself as a keylist without being enclosed in a list. All key values in the cl-case form must be distinct. The final clauses may use t in place of a keylist to indicate a default clause that should be taken if none of the other clauses match. (The symbol otherwise is also recognized in place of t. To make a clause that matches the actual symbol t, nil, or otherwise, enclose the symbol in a list.)

    For example, this expression reads a keystroke, then does one of four things depending on whether it is an ‘a’, a ‘b’, a RET or C-j, or anything else.

    (cl-case (read-char)
      (?a (do-a-thing))
      (?b (do-b-thing))
      ((?\r ?\n) (do-ret-thing))
      (t (do-other-thing)))

Macro: cl-ecase keyform clause… ¶

    This macro is just like cl-case, except that if the key does not match any of the clauses, an error is signaled rather than simply returning nil. 

Macro: cl-typecase keyform clause… ¶

    This macro is a version of cl-case that checks for types rather than values. Each clause is of the form ‘(type body…)’. See Type Predicates, for a description of type specifiers. For example,

    (cl-typecase x
      (integer (munch-integer x))
      (float (munch-float x))
      (string (munch-integer (string-to-number x)))
      (t (munch-anything x)))

    The type specifier t matches any type of object; the word otherwise is also allowed. To make one clause match any of several types, use an (or …) type specifier. 

Macro: cl-etypecase keyform clause… ¶

    This macro is just like cl-typecase, except that if the key does not match any of the clauses, an error is signaled rather than simply returning nil.  "
  (declare (indent 1) (debug ((symbolp form &optional form) body)))
  (unless (consp spec)
    (signal 'wrong-type-argument (list 'consp spec)))
  (unless (<= 2 (length spec) 3)
    (signal 'wrong-number-of-arguments (list '(2 . 3) (length spec))))
  ;; It would be cleaner to create an uninterned symbol,
  ;; but that uses a lot more space when many functions in many files
  ;; use dolist.
  ;; FIXME: This cost disappears in byte-compiled lexical-binding files.
  (let ((temp '--dolist-tail--))
    ;; This is not a reliable test, but it does not matter because both
    ;; semantics are acceptable, tho one is slightly faster with dynamic
    ;; scoping and the other is slightly faster (and has cleaner semantics)
    ;; with lexical scoping.
    (if lexical-binding
        `(let ((,temp ,(nth 1 spec)))
           (while ,temp
             (let ((,(car spec) (car ,temp)))
               ,@body
               (setq ,temp (cdr ,temp))))
           ,@(cdr (cdr spec)))
      `(let ((,temp ,(nth 1 spec))
             ,(car spec))
         (while ,temp
           (setq ,(car spec) (car ,temp))
           ,@body
           (setq ,temp (cdr ,temp)))
         ,@(if (cdr (cdr spec))
               `((setq ,(car spec) nil) ,@(cdr (cdr spec))))))))


(defmacro dotimes (spec &rest body)
  "4.3 Variable Bindings

These Lisp forms make bindings to variables and function names, analogous to Lisp’s built-in let form.

See Modify Macros, for the cl-letf and cl-letf* forms which are also related to variable bindings.

    Dynamic Bindings
    Function Bindings
    Macro Bindings "
  (declare (indent 1) (debug dolist))
  ;; It would be cleaner to create an uninterned symbol,
  ;; but that uses a lot more space when many functions in many files
  ;; use dotimes.
  ;; FIXME: This cost disappears in byte-compiled lexical-binding files.
  (let ((temp '--dotimes-limit--)
	(start 0)
	(end (nth 1 spec)))
    ;; This is not a reliable test, but it does not matter because both
    ;; semantics are acceptable, tho one is slightly faster with dynamic
    ;; scoping and the other has cleaner semantics.
    (if lexical-binding
        (let ((counter '--dotimes-counter--))
          `(let ((,temp ,end)
                 (,counter ,start))
             (while (< ,counter ,temp)
               (let ((,(car spec) ,counter))
                 ,@body)
               (setq ,counter (1+ ,counter)))
             ,@(if (cddr spec)
                   ;; FIXME: This let often leads to "unused var" warnings.
                   `((let ((,(car spec) ,counter)) ,@(cddr spec))))))
      `(let ((,temp ,end)
             (,(car spec) ,start))
         (while (< ,(car spec) ,temp)
           ,@body
           (setq ,(car spec) (1+ ,(car spec))))
         ,@(cdr (cdr spec))))))

(defmacro declare (&rest _specs)
  "4.3.1 Dynamic Bindings

The standard let form binds variables whose names are known at compile-time. The cl-progv form provides an easy way to bind variables whose names are computed at run-time.

Macro: cl-progv symbols values forms… ¶

    This form establishes let-style variable bindings on a set of variables computed at run-time. The expressions symbols and values are evaluated, and must return lists of symbols and values, respectively. The symbols are bound to the corresponding values for the duration of the body forms. If values is shorter than symbols, the last few symbols are bound to nil. If symbols is shorter than values, the excess values are ignored.  "
  ;; FIXME: edebug spec should pay attention to defun-declarations-alist.
  nil)

(defmacro packages-parlist (&rest body)
  "4.2.2 Modify Macros

This package defines a number of macros that operate on generalized variables. Many are interesting and useful even when the place is just a variable name.

Macro: cl-psetf [place form]… ¶

    This macro is to setf what cl-psetq is to setq: When several places and forms are involved, the assignments take place in parallel rather than sequentially. Specifically, all subforms are evaluated from left to right, then all the assignments are done (in an undefined order). 

Macro: cl-incf place &optional x ¶

    This macro increments the number stored in place by one, or by x if specified. The incremented value is returned. For example, (cl-incf i) is equivalent to (setq i (1+ i)), and (cl-incf (car x) 2) is equivalent to (setcar x (+ (car x) 2)).

    As with setf, care is taken to preserve the “apparent” order of evaluation. For example,

    (cl-incf (aref vec (cl-incf i)))

    appears to increment i once, then increment the element of vec addressed by i; this is indeed exactly what it does, which means the above form is not equivalent to the “obvious” expansion,

    (setf (aref vec (cl-incf i))
          (1+ (aref vec (cl-incf i))))   ; wrong!

    but rather to something more like

    (let ((temp (cl-incf i)))
      (setf (aref vec temp) (1+ (aref vec temp))))

    Again, all of this is taken care of automatically by cl-incf and the other generalized-variable macros.

    As a more Emacs-specific example of cl-incf, the expression (cl-incf (point) n) is essentially equivalent to (forward-char n). 

Macro: cl-decf place &optional x ¶

    This macro decrements the number stored in place by one, or by x if specified. 

Macro: cl-pushnew x place &key :test :test-not :key ¶

    This macro inserts x at the front of the list stored in place, but only if x isn’t present in the list already. The optional keyword arguments are interpreted in the same way as for cl-adjoin. See Lists as Sets. 

Macro: cl-shiftf place… newvalue ¶

    This macro shifts the places left by one, shifting in the value of newvalue (which may be any Lisp expression, not just a generalized variable), and returning the value shifted out of the first place. Thus, (cl-shiftf a b c d) is equivalent to

    (prog1
        a
      (cl-psetf a b
                b c
                c d))

    except that the subforms of a, b, and c are actually evaluated only once each and in the apparent order. 

Macro: cl-rotatef place… ¶

    This macro rotates the places left by one in circular fashion. Thus, (cl-rotatef a b c d) is equivalent to

    (cl-psetf a b
              b c
              c d
              d a)

    except for the evaluation of subforms. cl-rotatef always returns nil. Note that (cl-rotatef a b) conveniently exchanges a and b. 

The following macros were invented for this package; they have no analogues in Common Lisp.

Macro: cl-letf (bindings…) forms… ¶

    This macro is analogous to let, but for generalized variables rather than just symbols. Each binding should be of the form (place value); the original contents of the places are saved, the values are stored in them, and then the body forms are executed. Afterwards, the places are set back to their original saved contents. This cleanup happens even if the forms exit irregularly due to a throw or an error.

    For example,

    (cl-letf (((point) (point-min))
              (a 17))
         …)

    moves point in the current buffer to the beginning of the buffer, and also binds a to 17 (as if by a normal let, since a is just a regular variable). After the body exits, a is set back to its original value and point is moved back to its original position.

    Note that cl-letf on (point) is not quite like a save-excursion, as the latter effectively saves a marker which tracks insertions and deletions in the buffer. Actually, a cl-letf of (point-marker) is much closer to this behavior. (point and point-marker are equivalent as setf places; each will accept either an integer or a marker as the stored value.)

    Like in the case of let, the value forms are evaluated in the order they appear, but the order of bindings is unspecified. Therefore, avoid binding the same place more than once in a single cl-letf form.

    Since generalized variables look like lists, let’s shorthand of using ‘foo’ for ‘(foo nil)’ as a binding would be ambiguous in cl-letf and is not allowed.

    However, a binding specifier may be a one-element list ‘(place)’, which is similar to ‘(place place)’. In other words, the place is not disturbed on entry to the body, and the only effect of the cl-letf is to restore the original value of place afterwards.

    Note that in this case, and in fact almost every case, place must have a well-defined value outside the cl-letf body. There is essentially only one exception to this, which is place a plain variable with a specified value (such as (a 17) in the above example). 

Macro: cl-letf* (bindings…) forms… ¶

    This macro is to cl-letf what let* is to let: It does the bindings in sequential rather than parallel order. 

Macro: cl-callf function place args… ¶

    This is the “generic” modify macro. It calls function, which should be an unquoted function name, macro name, or lambda. It passes place and args as arguments, and assigns the result back to place. For example, (cl-incf place n) is the same as (cl-callf + place n). Some more examples:

    (cl-callf abs my-number)
    (cl-callf concat (buffer-name) "<" (number-to-string n) ">")
    (cl-callf cl-union happy-people (list joe bob) :test 'same-person)

    Note again that cl-callf is an extension to standard Common Lisp. 

Macro: cl-callf2 function arg1 place args… ¶

    This macro is like cl-callf, except that place is the second argument of function rather than the first. For example, (push x place) is equivalent to (cl-callf2 cons x place). 

The cl-callf and cl-callf2 macros serve as building blocks for other macros like cl-incf, and cl-pushnew. The cl-letf and cl-letf* macros are used in the processing of symbol macros; see Macro Bindings.

Macro: with-memoization place code… ¶

    This macro provides a simple way to do memoization. code is evaluated and then stashed in place. If place’s value is non-nil, return that value instead of evaluating code. "
  (declare (debug t) (indent 0))
  `(condition-case nil (progn ,@body) (error nil)))


;;;; Basic Lisp functions.

(defvar gensym-counter 0
  "Number used to construct the name of the next symbol created by `gensym'.")

(defun gensym (&optional prefix)
  "4.2 Generalized Variables

A generalized variable or place form is one of the many places in Lisp memory where values can be stored. The simplest place form is a regular Lisp variable. But the CARs and CDRs of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values are stored. For basic information, see Generalized Variables in GNU Emacs Lisp Reference Manual. This package provides several additional features related to generalized variables.

    Setf Extensions
    Modify Macros"
  (let ((num (prog1 gensym-counter
               (setq gensym-counter (1+ gensym-counter)))))
    (make-symbol (format "%s%d" (or prefix "g") num))))

(defun packages-parlist-include (&rest _arguments)
  "4.2.1 Setf Extensions

Several standard (e.g., car) and Emacs-specific (e.g., window-point) Lisp functions are setf-able by default. This package defines setf handlers for several additional functions:

    Functions from this package:

    cl-rest        cl-subseq      cl-get         cl-getf
    cl-caaar…cl-cddddr          cl-first…cl-tenth

    Note that for cl-getf (as for nthcdr), the list argument of the function must itself be a valid place form.
    A macro call, in which case the macro is expanded and setf is applied to the resulting form. 

The setf macro takes care to evaluate all subforms in the proper left-to-right order; for example,

(setf (aref vec (cl-incf i)) i)

looks like it will evaluate (cl-incf i) exactly once, before the following access to i; the setf expander will insert temporary variables as necessary to ensure that it does in fact work this way no matter what setf-method is defined for aref. (In this case, aset would be used and no such steps would be necessary since aset takes its arguments in a convenient order.)

However, if the place form is a macro which explicitly evaluates its arguments in an unusual order, this unusual order will be preserved. Adapting an example from Steele, given

(defmacro wrong-order (x y) (list 'aref y x))

the form (setf (wrong-order a b) 17) will evaluate b first, then a, just as in an actual call to wrong-order. "
  (interactive)
  nil)

;; Signal a compile-error if the first arg is missing.
(defun error (&rest args)
  "Signal an error, making a message by passing ARGS to `format-message'.
Errors cause entry to the debugger when `debug-on-error' is non-nil.
This can be overridden by `debug-ignored-errors'.

To signal with MESSAGE without interpreting format characters
like `%', `\\=`' and `\\='', use (error \"%s\" MESSAGE).
In Emacs, the convention is that error messages start with a capital
letter but *do not* end with a period.  Please follow this convention
for the sake of consistency."
  (declare (advertised-calling-convention (string &rest args) "23.1"))
  (signal 'error (list (apply #'format-message args))))

(defun packages-name-convert (format &rest args)
  "1.3 Naming Conventions

Except where noted, all functions defined by this package have the same calling conventions as their Common Lisp counterparts, and names that are those of Common Lisp plus a ‘cl-’ prefix.

Internal function and variable names in the package are prefixed by cl--. Here is a complete list of functions prefixed by cl- that were not taken from Common Lisp:

cl-callf           cl-callf2          cl-defsubst
cl-letf            cl-letf*

The following simple functions and macros are defined in cl-lib.el; they do not cause other components like cl-extra to be loaded.

cl-evenp           cl-oddp            cl-minusp
cl-plusp           cl-endp            cl-subst
cl-copy-list       cl-list*           cl-ldiff
cl-rest            cl-decf [1]        cl-incf [1]
cl-acons           cl-adjoin [2]      cl-pairlis
cl-pushnew [1,2]   cl-declaim         cl-proclaim
cl-caaar…cl-cddddr                  cl-first…cl-tenth
cl-mapcar [3]

[1] Only when place is a plain variable name.

[2] Only if :test is eq, equal, or unspecified, and :key is not used.

[3] Only for one sequence argument or two list arguments. "
  (signal 'user-error (list (apply #'format-message format args))))


(defun eval-time (name message &optional parent)
  "2.2 Time of Evaluation

Normally, the byte-compiler does not actually execute the forms in a file it compiles. For example, if a file contains (setq foo t), the act of compiling it will not actually set foo to t. This is true even if the setq was a top-level form (i.e., not enclosed in a defun or other form). Sometimes, though, you would like to have certain top-level forms evaluated at compile-time. For example, the compiler effectively evaluates defmacro forms at compile-time so that later parts of the file can refer to the macros that are defined.

Macro: cl-eval-when (situations…) forms… ¶

    This form controls when the body forms are evaluated. The situations list may contain any set of the symbols compile, load, and eval (or their long-winded ANSI equivalents, :compile-toplevel, :load-toplevel, and :execute).

    The cl-eval-when form is handled differently depending on whether or not it is being compiled as a top-level form. Specifically, it gets special treatment if it is being compiled by a command such as byte-compile-file which compiles files or buffers of code, and it appears either literally at the top level of the file or inside a top-level progn.

    For compiled top-level cl-eval-whens, the body forms are executed at compile-time if compile is in the situations list, and the forms are written out to the file (to be executed at load-time) if load is in the situations list.

    For non-compiled-top-level forms, only the eval situation is relevant. (This includes forms executed by the interpreter, forms compiled with byte-compile rather than byte-compile-file, and non-top-level forms.) The cl-eval-when acts like a progn if eval is specified, and like nil (ignoring the body forms) if not.

    The rules become more subtle when cl-eval-whens are nested; consult Steele (second edition) for the gruesome details (and some gruesome examples).

    Some simple examples:

    ;; Top-level forms in foo.el:
    (cl-eval-when (compile)           (setq foo1 'bar))
    (cl-eval-when (load)              (setq foo2 'bar))
    (cl-eval-when (compile load)      (setq foo3 'bar))
    (cl-eval-when (eval)              (setq foo4 'bar))
    (cl-eval-when (eval compile)      (setq foo5 'bar))
    (cl-eval-when (eval load)         (setq foo6 'bar))
    (cl-eval-when (eval compile load) (setq foo7 'bar))

    When foo.el is compiled, these variables will be set during the compilation itself:

    foo1  foo3  foo5  foo7      ; 'compile'

    When foo.elc is loaded, these variables will be set:

    foo2  foo3  foo6  foo7      ; 'load'

    And if foo.el is loaded uncompiled, these variables will be set:

    foo4  foo5  foo6  foo7      ; 'eval'

    If these seven cl-eval-whens had been, say, inside a defun, then the first three would have been equivalent to nil and the last four would have been equivalent to the corresponding setqs.

    Note that (cl-eval-when (load eval) …) is equivalent to (progn …) in all contexts. The compiler treats certain top-level forms, like defmacro (sort-of) and require, as if they were wrapped in (cl-eval-when (compile load eval) …). 

Emacs includes two special forms related to cl-eval-when. See Eval During Compile in GNU Emacs Lisp Reference Manual. One of these, eval-when-compile, is not quite equivalent to any cl-eval-when construct and is described below.

The other form, (eval-and-compile …), is exactly equivalent to ‘(cl-eval-when (compile load eval) …)’.

Macro: eval-when-compile forms… ¶

    The forms are evaluated at compile-time; at execution time, this form acts like a quoted constant of the resulting value. Used at top-level, eval-when-compile is just like ‘eval-when (compile eval)’. In other contexts, eval-when-compile allows code to be evaluated once at compile-time for efficiency or other reasons.

    This form is similar to the ‘#.’ syntax of true Common Lisp. 

Macro: cl-load-time-value form ¶

    The form is evaluated at load-time; at execution time, this form acts like a quoted constant of the resulting value.

    Early Common Lisp had a ‘#,’ syntax that was similar to this, but ANSI Common Lisp replaced it with load-time-value and gave it more well-defined semantics.

    In a compiled file, cl-load-time-value arranges for form to be evaluated when the .elc file is loaded and then used as if it were a quoted constant. In code compiled by byte-compile rather than byte-compile-file, the effect is identical to eval-when-compile. In uncompiled code, both eval-when-compile and cl-load-time-value act exactly like progn.

    (defun report ()
      (insert "This function was executed on: "
              (current-time-string)
              ", compiled on: "
              (eval-when-compile (current-time-string))
              ;; or '#.(current-time-string) in real Common Lisp
              ", and loaded on: "
              (cl-load-time-value (current-time-string))))

    Byte-compiled, the above defun will result in the following code (or its compiled equivalent, of course) in the .elc file:

    (setq --temp-- (current-time-string))
    (defun report ()
      (insert "This function was executed on: "
              (current-time-string)
              ", compiled on: "
              '"Wed Oct 31 16:32:28 2012"
              ", and loaded on: "
              --temp--)) "
  (unless parent (setq parent 'error))
  (let ((conditions
         (if (consp parent)
             (apply #'append
                    (mapcar (lambda (parent)
                              (cons parent
                                    (or (get parent 'error-conditions)
                                        (error "Unknown signal `%s'" parent))))
                            parent))
           (cons parent (get parent 'error-conditions)))))
    (put name 'error-conditions
         (delete-dups (copy-sequence (cons name conditions))))
    (when message (put name 'error-message message))))

;; We put this here instead of in frame.el so that it's defined even on
;; systems where frame.el isn't loaded.
(defun frame-configuration-p (object)
  "3.1 Type Predicates

Function: cl-typep object type ¶

    Check if object is of type type, where type is a (quoted) type name of the sort used by Common Lisp. For example, (cl-typep foo 'integer) is equivalent to (integerp foo). 

The type argument to the above function is either a symbol or a list beginning with a symbol.

    If the type name is a symbol, Emacs appends ‘-p’ to the symbol name to form the name of a predicate function for testing the type. (Built-in predicates whose names end in ‘p’ rather than ‘-p’ are used when appropriate.)
    The type symbol t stands for the union of all types. (cl-typep object t) is always true. Likewise, the type symbol nil stands for nothing at all, and (cl-typep object nil) is always false.
    The type symbol null represents the symbol nil. Thus (cl-typep object 'null) is equivalent to (null object).
    The type symbol atom represents all objects that are not cons cells. Thus (cl-typep object 'atom) is equivalent to (atom object).
    The type symbol real is a synonym for number, and fixnum is a synonym for integer.
    The type symbols character and string-char match integers in the range from 0 to 255.
    The type list (integer low high) represents all integers between low and high, inclusive. Either bound may be a list of a single integer to specify an exclusive limit, or a * to specify no limit. The type (integer * *) is thus equivalent to integer.
    Likewise, lists beginning with float, real, or number represent numbers of that type falling in a particular range.
    Lists beginning with and, or, and not form combinations of types. For example, (or integer (float 0 *)) represents all objects that are integers or non-negative floats.
    Lists beginning with member or cl-member represent objects eql to any of the following values. For example, (member 1 2 3 4) is equivalent to (integer 1 4), and (member nil) is equivalent to null.
    Lists of the form (satisfies predicate) represent all objects for which predicate returns true when called with that object as an argument. 

The following function and macro (not technically predicates) are related to cl-typep.

Function: cl-coerce object type ¶

    This function attempts to convert object to the specified type. If object is already of that type as determined by cl-typep, it is simply returned. Otherwise, certain types of conversions will be made: If type is any sequence type (string, list, etc.) then object will be converted to that type if possible. If type is character, then strings of length one and symbols with one-character names can be coerced. If type is float, then integers can be coerced in versions of Emacs that support floats. In all other circumstances, cl-coerce signals an error. 

Macro: cl-deftype name arglist forms… ¶

    This macro defines a new type called name. It is similar to defmacro in many ways; when name is encountered as a type name, the body forms are evaluated and should return a type specifier that is equivalent to the type. The arglist is a Common Lisp argument list of the sort accepted by cl-defmacro. The type specifier ‘(name args…)’ is expanded by calling the expander with those arguments; the type symbol ‘name’ is expanded by calling the expander with no arguments. The arglist is processed the same as for cl-defmacro except that optional arguments without explicit defaults use * instead of nil as the “default” default. Some examples:

    (cl-deftype null () '(satisfies null))    ; predefined
    (cl-deftype list () '(or null cons))      ; predefined
    (cl-deftype unsigned-byte (&optional bits)
      (list 'integer 0 (if (eq bits '*) bits (1- (ash 1 bits)))))
    (unsigned-byte 8)  ≡  (integer 0 255)
    (unsigned-byte)  ≡  (integer 0 *)
    unsigned-byte  ≡  (integer 0 *)

    The last example shows how the Common Lisp unsigned-byte type specifier could be implemented if desired; this package does not implement unsigned-byte by default. 

The cl-typecase (see Conditionals) and cl-check-type (see Assertions and Errors) macros also use type names. The cl-map, cl-concatenate, and cl-merge functions take type-name arguments to specify the type of sequence to return. See Sequences. "
  (and (consp object)
       (eq (car object) 'frame-configuration)))

(defun apply-partially (fun &rest args)
  "3 Predicates

This section describes functions for testing whether various facts are true or false.

    Type Predicates
    Equality Predicates"
  (lambda (&rest args2)
    (apply fun (append args args2))))

(defun zerop (number)
  "3.2 Equality Predicates

This package defines the Common Lisp predicate cl-equalp.

Function: cl-equalp a b ¶

    This function is a more flexible version of equal. In particular, it compares strings case-insensitively, and it compares numbers without regard to type (so that (cl-equalp 3 3.0) is true). Vectors and conses are compared recursively. All other objects are compared as if by equal.

    This function differs from Common Lisp equalp in several respects. First, Common Lisp’s equalp also compares characters case-insensitively, which would be impractical in this package since Emacs does not distinguish between integers and characters. In keeping with the idea that strings are less vector-like in Emacs Lisp, this package’s cl-equalp also will not compare strings against vectors of integers. 

Also note that the Common Lisp functions member and assoc use eql to compare elements, whereas Emacs Lisp follows the MacLisp tradition and uses equal for these two functions. The functions cl-member and cl-assoc use eql, as in Common Lisp. The standard Emacs Lisp functions memq and assq use eq, and the standard memql uses eql.  "
  ;; Used to be in C, but it's pointless since (= 0 n) is faster anyway because
  ;; = has a byte-code.
  (declare (compiler-macro (lambda (_) `(= 0 ,number))))
  (= 0 number))

(defun fixnump (object)
  "4.1 Assignment

The cl-psetq form is just like setq, except that multiple assignments are done in parallel rather than sequentially.

Macro: cl-psetq [symbol form]… ¶

    This special form (actually a macro) is used to assign to several variables simultaneously. Given only one symbol and form, it has the same effect as setq. Given several symbol and form pairs, it evaluates all the forms in advance and then stores the corresponding variables afterwards.

    (setq x 2 y 3)
    (setq x (+ x y)  y (* x y))
    x
         ⇒ 5
    y                     ; y was computed after x was set.
         ⇒ 15
    (setq x 2 y 3)
    (cl-psetq x (+ x y)  y (* x y))
    x
         ⇒ 5
    y                     ; y was computed before x was set.
         ⇒ 6

    The simplest use of cl-psetq is (cl-psetq x y y x), which exchanges the values of two variables. (The cl-rotatef form provides an even more convenient way to swap two variables; see Modify Macros.)

    cl-psetq always returns nil. "
  (and (integerp object)
       (<= most-negative-fixnum object most-positive-fixnum)))

(defun bignump (object)
  "4.4 Conditionals

These conditional forms augment Emacs Lisp’s simple if, and, or, and cond forms.

Macro: cl-case keyform clause… ¶

    This macro evaluates keyform, then compares it with the key values listed in the various clauses. Whichever clause matches the key is executed; comparison is done by eql. If no clause matches, the cl-case form returns nil. The clauses are of the form

    (keylist body-forms…)

    where keylist is a list of key values. If there is exactly one value, and it is not a cons cell or the symbol nil or t, then it can be used by itself as a keylist without being enclosed in a list. All key values in the cl-case form must be distinct. The final clauses may use t in place of a keylist to indicate a default clause that should be taken if none of the other clauses match. (The symbol otherwise is also recognized in place of t. To make a clause that matches the actual symbol t, nil, or otherwise, enclose the symbol in a list.)

    For example, this expression reads a keystroke, then does one of four things depending on whether it is an ‘a’, a ‘b’, a RET or C-j, or anything else.

    (cl-case (read-char)
      (?a (do-a-thing))
      (?b (do-b-thing))
      ((?\r ?\n) (do-ret-thing))
      (t (do-other-thing)))

Macro: cl-ecase keyform clause… ¶

    This macro is just like cl-case, except that if the key does not match any of the clauses, an error is signaled rather than simply returning nil. 

Macro: cl-typecase keyform clause… ¶

    This macro is a version of cl-case that checks for types rather than values. Each clause is of the form ‘(type body…)’. See Type Predicates, for a description of type specifiers. For example,

    (cl-typecase x
      (integer (munch-integer x))
      (float (munch-float x))
      (string (munch-integer (string-to-number x)))
      (t (munch-anything x)))

    The type specifier t matches any type of object; the word otherwise is also allowed. To make one clause match any of several types, use an (or …) type specifier. 

Macro: cl-etypecase keyform clause… ¶

    This macro is just like cl-typecase, except that if the key does not match any of the clauses, an error is signaled rather than simply returning nil. "
  (and (integerp object) (not (fixnump object))))

(defun lsh (value count)
  "4.7 Loop Facility

A common complaint with Lisp’s traditional looping constructs was that they were either too simple and limited, such as dotimes or while, or too unreadable and obscure, like Common Lisp’s do loop.

To remedy this, Common Lisp added a construct called the “Loop Facility” or “loop macro”, with an easy-to-use but very powerful and expressive syntax.

    Loop Basics
    Loop Examples
    For Clauses
    Iteration Clauses
    Accumulation Clauses
    Other Clauses "
  (when (and (< value 0) (< count 0))
    (when (< value most-negative-fixnum)
      (signal 'args-out-of-range (list value count)))
    (setq value (logand (ash value -1) most-positive-fixnum))
    (setq count (1+ count)))
  (ash value count))



;;;; List functions.

;; Note: `internal--compiler-macro-cXXr' was copied from
;; `cl--compiler-macro-cXXr' in cl-macs.el.  If you amend either one,
;; you may want to amend the other, too.
(defun internal--compiler-macro-cXXr (form x)
  (let* ((head (car form))
         (n (symbol-name (car form)))
         (i (- (length n) 2)))
    (if (not (string-match "c[ad]+r\\'" n))
        (if (and (fboundp head) (symbolp (symbol-function head)))
            (internal--compiler-macro-cXXr (cons (symbol-function head) (cdr form))
                                     x)
          (error "Compiler macro for cXXr applied to non-cXXr form"))
      (while (> i (match-beginning 0))
        (setq x (list (if (eq (aref n i) ?a) 'car 'cdr) x))
        (setq i (1- i)))
      x)))

(defun caar (x)
  "4.7.1 Loop Basics

The cl-loop macro essentially creates a mini-language within Lisp that is specially tailored for describing loops. While this language is a little strange-looking by the standards of regular Lisp, it turns out to be very easy to learn and well-suited to its purpose.

Since cl-loop is a macro, all parsing of the loop language takes place at byte-compile time; compiled cl-loops are just as efficient as the equivalent while loops written longhand.

Macro: cl-loop clauses… ¶

    A loop construct consists of a series of clauses, each introduced by a symbol like for or do. Clauses are simply strung together in the argument list of cl-loop, with minimal extra parentheses. The various types of clauses specify initializations, such as the binding of temporary variables, actions to be taken in the loop, stepping actions, and final cleanup.

    Common Lisp specifies a certain general order of clauses in a loop:

    (loop name-clause
          var-clauses…
          action-clauses…)

    The name-clause optionally gives a name to the implicit block that surrounds the loop. By default, the implicit block is named nil. The var-clauses specify what variables should be bound during the loop, and how they should be modified or iterated throughout the course of the loop. The action-clauses are things to be done during the loop, such as computing, collecting, and returning values.

    The Emacs version of the cl-loop macro is less restrictive about the order of clauses, but things will behave most predictably if you put the variable-binding clauses with, for, and repeat before the action clauses. As in Common Lisp, initially and finally clauses can go anywhere.

    Loops generally return nil by default, but you can cause them to return a value by using an accumulation clause like collect, an end-test clause like always, or an explicit return clause to jump out of the implicit block. (Because the loop body is enclosed in an implicit block, you can also use regular Lisp cl-return or cl-return-from to break out of the loop.) 

The following sections give some examples of the loop macro in action, and describe the particular loop clauses in great detail. Consult the second edition of Steele for additional discussion and examples. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (car x)))


(defun cadr (x)
  "4.7.2 Loop Examples

Before listing the full set of clauses that are allowed, let’s look at a few example loops just to get a feel for the cl-loop language.

(cl-loop for buf in (buffer-list)
         collect (buffer-file-name buf))

This loop iterates over all Emacs buffers, using the list returned by buffer-list. For each buffer buf, it calls buffer-file-name and collects the results into a list, which is then returned from the cl-loop construct. The result is a list of the file names of all the buffers in Emacs’s memory. The words for, in, and collect are reserved words in the cl-loop language.

(cl-loop repeat 20 do (insert "Yowsa\n"))

This loop inserts the phrase “Yowsa” twenty times in the current buffer.

(cl-loop until (eobp) do (munch-line) (forward-line 1))

This loop calls munch-line on every line until the end of the buffer. If point is already at the end of the buffer, the loop exits immediately.

(cl-loop do (munch-line) until (eobp) do (forward-line 1))

This loop is similar to the above one, except that munch-line is always called at least once.

(cl-loop for x from 1 to 100
         for y = (* x x)
         until (>= y 729)
         finally return (list x (= y 729)))

This more complicated loop searches for a number x whose square is 729. For safety’s sake it only examines x values up to 100; dropping the phrase ‘to 100’ would cause the loop to count upwards with no limit. The second for clause defines y to be the square of x within the loop; the expression after the = sign is reevaluated each time through the loop. The until clause gives a condition for terminating the loop, and the finally clause says what to do when the loop finishes. (This particular example was written less concisely than it could have been, just for the sake of illustration.)

Note that even though this loop contains three clauses (two fors and an until) that would have been enough to define loops all by themselves, it still creates a single loop rather than some sort of triple-nested loop. You must explicitly nest your cl-loop constructs if you want nested loops. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr x)))

(defun cdar (x)
  "4.7.3 For Clauses

Most loops are governed by one or more for clauses. A for clause simultaneously describes variables to be bound, how those variables are to be stepped during the loop, and usually an end condition based on those variables.

The word as is a synonym for the word for. This word is followed by a variable name, then a word like from or across that describes the kind of iteration desired. In Common Lisp, the phrase being the sometimes precedes the type of iteration; in this package both being and the are optional. The word each is a synonym for the, and the word that follows it may be singular or plural: ‘for x being the elements of y’ or ‘for x being each element of y’. Which form you use is purely a matter of style.

The variable is bound around the loop as if by let:

(setq i 'happy)
(cl-loop for i from 1 to 10 do (do-something-with i))
i
     ⇒ happy

for var from expr1 to expr2 by expr3

    This type of for clause creates a counting loop. Each of the three sub-terms is optional, though there must be at least one term so that the clause is marked as a counting clause.

    The three expressions are the starting value, the ending value, and the step value, respectively, of the variable. The loop counts upwards by default (expr3 must be positive), from expr1 to expr2 inclusively. If you omit the from term, the loop counts from zero; if you omit the to term, the loop counts forever without stopping (unless stopped by some other loop clause, of course); if you omit the by term, the loop counts in steps of one.

    You can replace the word from with upfrom or downfrom to indicate the direction of the loop. Likewise, you can replace to with upto or downto. For example, ‘for x from 5 downto 1’ executes five times with x taking on the integers from 5 down to 1 in turn. Also, you can replace to with below or above, which are like upto and downto respectively except that they are exclusive rather than inclusive limits:

    (cl-loop for x to 10 collect x)
            ⇒ (0 1 2 3 4 5 6 7 8 9 10)
    (cl-loop for x below 10 collect x)
            ⇒ (0 1 2 3 4 5 6 7 8 9)

    The by value is always positive, even for downward-counting loops. Some sort of from value is required for downward loops; ‘for x downto 5’ is not a valid loop clause all by itself.
for var in list by function

    This clause iterates var over all the elements of list, in turn. If you specify the by term, then function is used to traverse the list instead of cdr; it must be a function taking one argument. For example:

    (cl-loop for x in '(1 2 3 4 5 6) collect (* x x))
            ⇒ (1 4 9 16 25 36)
    (cl-loop for x in '(1 2 3 4 5 6) by 'cddr collect (* x x))
            ⇒ (1 9 25)

for var on list by function

    This clause iterates var over all the cons cells of list.

    (cl-loop for x on '(1 2 3 4) collect x)
            ⇒ ((1 2 3 4) (2 3 4) (3 4) (4))

for var in-ref list by function

    This is like a regular in clause, but var becomes a setf-able “reference” onto the elements of the list rather than just a temporary variable. For example,

    (cl-loop for x in-ref my-list do (cl-incf x))

    increments every element of my-list in place. This clause is an extension to standard Common Lisp.
for var across array

    This clause iterates var over all the elements of array, which may be a vector or a string.

    (cl-loop for x across "aeiou"
             do (use-vowel (char-to-string x)))

for var across-ref array

    This clause iterates over an array, with var a setf-able reference onto the elements; see in-ref above.
for var being the elements of sequence

    This clause iterates over the elements of sequence, which may be a list, vector, or string. Since the type must be determined at run-time, this is somewhat less efficient than in or across. The clause may be followed by the additional term ‘using (index var2)’ to cause var2 to be bound to the successive indices (starting at 0) of the elements.

    This clause type is taken from older versions of the loop macro, and is not present in modern Common Lisp. The ‘using (sequence …)’ term of the older macros is not supported.
for var being the elements of-ref sequence

    This clause iterates over a sequence, with var a setf-able reference onto the elements; see in-ref above.
for var being the symbols [of obarray]

    This clause iterates over symbols, either over all interned symbols or over all symbols in obarray. The loop is executed with var bound to each symbol in turn. The symbols are visited in an unspecified order.

    As an example,

    (cl-loop for sym being the symbols
             when (fboundp sym)
             when (string-match "^map" (symbol-name sym))
             collect sym)

    returns a list of all the functions whose names begin with ‘map’.

    The Common Lisp words external-symbols and present-symbols are also recognized but are equivalent to symbols in Emacs Lisp.

    Due to a minor implementation restriction, it will not work to have more than one for clause iterating over symbols, hash tables, keymaps, overlays, or intervals in a given cl-loop. Fortunately, it would rarely if ever be useful to do so. It is valid to mix one of these types of clauses with other clauses like for … to or while.
for var being the hash-keys of hash-table
for var being the hash-values of hash-table

    This clause iterates over the entries in hash-table with var bound to each key, or value. A ‘using’ clause can bind a second variable to the opposite part.

    (cl-loop for k being the hash-keys of h
                   using (hash-values v)
             do
             (message "key %S -> value %S" k v))

for var being the key-codes of keymap
for var being the key-bindings of keymap

    This clause iterates over the entries in keymap. The iteration does not enter nested keymaps but does enter inherited (parent) keymaps. A using clause can access both the codes and the bindings together.

    (cl-loop for c being the key-codes of (current-local-map)
                   using (key-bindings b)
             do
             (message "key %S -> binding %S" c b))

for var being the key-seqs of keymap

    This clause iterates over all key sequences defined by keymap and its nested keymaps, where var takes on values which are vectors. The strings or vectors are reused for each iteration, so you must copy them if you wish to keep them permanently. You can add a ‘using (key-bindings …)’ clause to get the command bindings as well.
for var being the overlays [of buffer] …

    This clause iterates over the “overlays” of a buffer (the clause extents is synonymous with overlays). If the of term is omitted, the current buffer is used. This clause also accepts optional ‘from pos’ and ‘to pos’ terms, limiting the clause to overlays which overlap the specified region.
for var being the intervals [of object] …

    This clause iterates over all intervals of a buffer or string with constant text properties. The variable var will be bound to conses of start and end positions, where one start position is always equal to the previous end position. The clause allows of, from, to, and property terms, where the latter term restricts the search to just the specified property. The of term may specify either a buffer or a string. See (elisp)Text Properties.
for var being the frames

    This clause iterates over all Emacs frames. The clause screens is a synonym for frames. The frames are visited in next-frame order starting from selected-frame.
for var being the windows [of frame]

    This clause iterates over the windows (in the Emacs sense) of the current frame, or of the specified frame. It visits windows in next-window order starting from selected-window (or frame-selected-window if you specify frame). This clause treats the minibuffer window in the same way as next-window does. For greater flexibility, consider using walk-windows instead.
for var being the buffers

    This clause iterates over all buffers in Emacs. It is equivalent to ‘for var in (buffer-list)’.
for var = expr1 then expr2

    This clause does a general iteration. The first time through the loop, var will be bound to expr1. On the second and successive iterations it will be set by evaluating expr2 (which may refer to the old value of var). For example, these two loops are effectively the same:

    (cl-loop for x on my-list by 'cddr do …)
    (cl-loop for x = my-list then (cddr x) while x do …)

    Note that this type of for clause does not imply any sort of terminating condition; the above example combines it with a while clause to tell when to end the loop.

    If you omit the then term, expr1 is used both for the initial setting and for successive settings:

    (cl-loop for x = (random) when (> x 0) return x)

    This loop keeps taking random numbers from the (random) function until it gets a positive one, which it then returns. 

If you include several for clauses in a row, they are treated sequentially (as if by let* and setq). You can instead use the word and to link the clauses, in which case they are processed in parallel (as if by let and cl-psetq).

(cl-loop for x below 5 for y = nil then x collect (list x y))
        ⇒ ((0 nil) (1 1) (2 2) (3 3) (4 4))
(cl-loop for x below 5 and y = nil then x collect (list x y))
        ⇒ ((0 nil) (1 0) (2 1) (3 2) (4 3))

In the first loop, y is set based on the value of x that was just set by the previous clause; in the second loop, x and y are set simultaneously so y is set based on the value of x left over from the previous time through the loop.

Another feature of the cl-loop macro is destructuring, similar in concept to the destructuring provided by defmacro (see Argument Lists). The var part of any for clause can be given as a list of variables instead of a single variable. The values produced during loop execution must be lists; the values in the lists are stored in the corresponding variables.

(cl-loop for (x y) in '((2 3) (4 5) (6 7)) collect (+ x y))
        ⇒ (5 9 13)

In loop destructuring, if there are more values than variables the trailing values are ignored, and if there are more variables than values the trailing variables get the value nil. If nil is used as a variable name, the corresponding values are ignored. Destructuring may be nested, and dotted lists of variables like (x . y) are allowed, so for example to process an alist

(cl-loop for (key . value) in '((a . 1) (b . 2))
         collect value)
        ⇒ (1 2)
"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (car x)))

(defun cddr (x)
  "4.7.4 Iteration Clauses

Aside from for clauses, there are several other loop clauses that control the way the loop operates. They might be used by themselves, or in conjunction with one or more for clauses.

repeat integer

    This clause simply counts up to the specified number using an internal temporary variable. The loops

    (cl-loop repeat (1+ n) do …)
    (cl-loop for temp to n do …)

    are identical except that the second one forces you to choose a name for a variable you aren’t actually going to use.
while condition

    This clause stops the loop when the specified condition (any Lisp expression) becomes nil. For example, the following two loops are equivalent, except for the implicit nil block that surrounds the second one:

    (while cond forms…)
    (cl-loop while cond do forms…)

until condition

    This clause stops the loop when the specified condition is true, i.e., non-nil.
always condition

    This clause stops the loop when the specified condition is nil. Unlike while, it stops the loop using return nil so that the finally clauses are not executed. If all the conditions were non-nil, the loop returns t:

    (if (cl-loop for size in size-list always (> size 10))
        (only-big-sizes)
      (some-small-sizes))

never condition

    This clause is like always, except that the loop returns t if all conditions were false, or nil otherwise.
thereis condition

    This clause stops the loop when the specified form is non-nil; in this case, it returns that non-nil value. If all the values were nil, the loop returns nil.
iter-by iterator

    This clause iterates over the values from the specified form, an iterator object. See (see Generators in GNU Emacs Lisp Reference Manual). 
"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (cdr x)))

(defun caaar (x)
  "4.7.5 Accumulation Clauses

These clauses cause the loop to accumulate information about the specified Lisp form. The accumulated result is returned from the loop unless overridden, say, by a return clause.

collect form

    This clause collects the values of form into a list. Several examples of collect appear elsewhere in this manual.

    The word collecting is a synonym for collect, and likewise for the other accumulation clauses.
append form

    This clause collects lists of values into a result list using append.
nconc form

    This clause collects lists of values into a result list by destructively modifying the lists rather than copying them.
concat form

    This clause concatenates the values of the specified form into a string. (It and the following clause are extensions to standard Common Lisp.)
vconcat form

    This clause concatenates the values of the specified form into a vector.
count form

    This clause counts the number of times the specified form evaluates to a non-nil value.
sum form

    This clause accumulates the sum of the values of the specified form, which must evaluate to a number.
maximize form

    This clause accumulates the maximum value of the specified form, which must evaluate to a number. The return value is undefined if maximize is executed zero times.
minimize form

    This clause accumulates the minimum value of the specified form. 

Accumulation clauses can be followed by ‘into var’ to cause the data to be collected into variable var (which is automatically let-bound during the loop) rather than an unnamed temporary variable. Also, into accumulations do not automatically imply a return value. The loop must use some explicit mechanism, such as finally return, to return the accumulated result.

It is valid for several accumulation clauses of the same type to accumulate into the same place. From Steele:

(cl-loop for name in '(fred sue alice joe june)
         for kids in '((bob ken) () () (kris sunshine) ())
         collect name
         append kids)
        ⇒ (fred bob ken sue alice joe kris sunshine june) "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (car (car x))))


(defun caadr (x)
  "4.7.6 Other Clauses

This section describes the remaining loop clauses.

with var = value

    This clause binds a variable to a value around the loop, but otherwise leaves the variable alone during the loop. The following loops are basically equivalent:

    (cl-loop with x = 17 do …)
    (let ((x 17)) (cl-loop do …))
    (cl-loop for x = 17 then x do …)

    Naturally, the variable var might be used for some purpose in the rest of the loop. For example:

    (cl-loop for x in my-list  with res = nil  do (push x res)
             finally return res)

    This loop inserts the elements of my-list at the front of a new list being accumulated in res, then returns the list res at the end of the loop. The effect is similar to that of a collect clause, but the list gets reversed by virtue of the fact that elements are being pushed onto the front of res rather than the end.

    If you omit the = term, the variable is initialized to nil. (Thus the ‘= nil’ in the above example is unnecessary.)

    Bindings made by with are sequential by default, as if by let*. Just like for clauses, with clauses can be linked with and to cause the bindings to be made by let instead.
if condition clause

    This clause executes the following loop clause only if the specified condition is true. The following clause should be an accumulation, do, return, if, or unless clause. Several clauses may be linked by separating them with and. These clauses may be followed by else and a clause or clauses to execute if the condition was false. The whole construct may optionally be followed by the word end (which may be used to disambiguate an else or and in a nested if).

    The actual non-nil value of the condition form is available by the name it in the “then” part. For example:

    (setq funny-numbers '(6 13 -1))
         ⇒ (6 13 -1)
    (cl-loop for x below 10
             if (cl-oddp x)
               collect x into odds
               and if (memq x funny-numbers) return (cdr it) end
             else
               collect x into evens
             finally return (vector odds evens))
            ⇒ [(1 3 5 7 9) (0 2 4 6 8)]
    (setq funny-numbers '(6 7 13 -1))
         ⇒ (6 7 13 -1)
    (cl-loop <same thing again>)
            ⇒ (13 -1)

    Note the use of and to put two clauses into the “then” part, one of which is itself an if clause. Note also that end, while normally optional, was necessary here to make it clear that the else refers to the outermost if clause. In the first case, the loop returns a vector of lists of the odd and even values of x. In the second case, the odd number 7 is one of the funny-numbers so the loop returns early; the actual returned value is based on the result of the memq call.
when condition clause

    This clause is just a synonym for if.
unless condition clause

    The unless clause is just like if except that the sense of the condition is reversed.
named name

    This clause gives a name other than nil to the implicit block surrounding the loop. The name is the symbol to be used as the block name.
initially [do] forms…

    This keyword introduces one or more Lisp forms which will be executed before the loop itself begins (but after any variables requested by for or with have been bound to their initial values). initially clauses can appear anywhere; if there are several, they are executed in the order they appear in the loop. The keyword do is optional.
finally [do] forms…

    This introduces Lisp forms which will be executed after the loop finishes (say, on request of a for or while). initially and finally clauses may appear anywhere in the loop construct, but they are executed (in the specified order) at the beginning or end, respectively, of the loop.
finally return form

    This says that form should be executed after the loop is done to obtain a return value. (Without this, or some other clause like collect or return, the loop will simply return nil.) Variables bound by for, with, or into will still contain their final values when form is executed.
do forms…

    The word do may be followed by any number of Lisp expressions which are executed as an implicit progn in the body of the loop. Many of the examples in this section illustrate the use of do.
return form

    This clause causes the loop to return immediately. The following Lisp form is evaluated to give the return value of the loop form. The finally clauses, if any, are not executed. Of course, return is generally used inside an if or unless, as its use in a top-level loop clause would mean the loop would never get to “loop” more than once.

    The clause ‘return form’ is equivalent to ‘do (cl-return form)’ (or cl-return-from if the loop was named). The return clause is implemented a bit more efficiently, though. 

While there is no high-level way to add user extensions to cl-loop, this package does offer two properties called cl-loop-handler and cl-loop-for-handler which are functions to be called when a given symbol is encountered as a top-level loop clause or for clause, respectively. Consult the source code in file cl-macs.el for details.

This package’s cl-loop macro is compatible with that of Common Lisp, except that a few features are not implemented: loop-finish and data-type specifiers. Naturally, the for clauses that iterate over keymaps, overlays, intervals, frames, windows, and buffers are Emacs-specific extensions.  "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (car (cdr x))))

(defun cadar (x)
  "4.8 Multiple Values

Common Lisp functions can return zero or more results. Emacs Lisp functions, by contrast, always return exactly one result. This package makes no attempt to emulate Common Lisp multiple return values; Emacs versions of Common Lisp functions that return more than one value either return just the first value (as in cl-compiler-macroexpand) or return a list of values. This package does define placeholders for the Common Lisp functions that work with multiple values, but in Emacs Lisp these functions simply operate on lists instead. The cl-values form, for example, is a synonym for list in Emacs.

Macro: cl-multiple-value-bind (var…) values-form forms… ¶

    This form evaluates values-form, which must return a list of values. It then binds the vars to these respective values, as if by let, and then executes the body forms. If there are more vars than values, the extra vars are bound to nil. If there are fewer vars than values, the excess values are ignored. 

Macro: cl-multiple-value-setq (var…) form ¶

    This form evaluates form, which must return a list of values. It then sets the vars to these respective values, as if by setq. Extra vars or values are treated the same as in cl-multiple-value-bind. 

Since a perfect emulation is not feasible in Emacs Lisp, this package opts to keep it as simple and predictable as possible. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (car x))))

(defun caddr (x)
  "4.9 Macro-Writing Macros

This package includes two classic Common Lisp macro-writing macros to help render complex macrology easier to read.

Macro: cl-with-gensyms names… body ¶

    This macro expands to code that executes body with each of the variables in names bound to a fresh uninterned symbol, or gensym, in Common Lisp parlance. For macros requiring more than one gensym, use of cl-with-gensyms shortens the code and renders one’s intentions clearer. Compare:

    (defmacro my-macro (foo)
      (let ((bar (gensym "bar"))
            (baz (gensym "baz"))
            (quux (gensym "quux")))
        `(let ((,bar (+ …)))
           …)))

    (defmacro my-macro (foo)
      (cl-with-gensyms (bar baz quux)
        `(let ((,bar (+ …)))
           …)))

Macro: cl-once-only ((variable form)…) body ¶

    This macro is primarily to help the macro programmer ensure that forms supplied by the user of the macro are evaluated just once by its expansion even though the result of evaluating the form is to occur more than once. Less often, this macro is used to ensure that forms supplied by the macro programmer are evaluated just once.

    Each variable may be used to refer to the result of evaluating form in body. cl-once-only binds each variable to a fresh uninterned symbol during the evaluation of body. Then, cl-once-only wraps the final expansion in code to evaluate each form and bind the result to the corresponding uninterned symbol. Thus, when the macro writer substitutes the value for variable into the expansion they are effectively referring to the result of evaluating form, rather than form itself. Another way to put this is that each variable is bound to an expression for the (singular) result of evaluating form.

    The most common case is where variable is one of the arguments to the macro being written, so (variable variable) may be abbreviated to just variable.

    For example, consider this macro:

    (defmacro my-list (x y &rest forms)
      (let ((x-result (gensym))
            (y-result (gensym)))
        `(let ((,x-result ,x)
               (,y-result ,y))
           (list ,x-result ,y-result ,x-result ,y-result
                 (progn ,@forms))))

    In a call like (my-list (pop foo) …) the intermediate binding to x-result ensures that the pop is not done twice. But as a result the code is rather complex: the reader must keep track of how x-result really just means the first parameter of the call to the macro, and the required use of multiple gensyms to avoid variable capture by (progn ,@forms) obscures things further. cl-once-only takes care of these details:

    (defmacro my-list (x y &rest forms)
      (cl-once-only (x y)
        `(list ,x ,y ,x ,y
               (progn ,@forms))))"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (cdr x))))

(defun cdaar (x)
  "4 Control Structure

The features described in the following sections implement various advanced control structures, including extensions to the standard setf facility, and a number of looping and conditional constructs.

    Assignment
    Generalized Variables
    Variable Bindings
    Conditionals
    Blocks and Exits
    Iteration
    Loop Facility
    Multiple Values
    Macro-Writing Macros"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (car (car x))))

(defun cdadr (x)
  "4.1 Assignment

The cl-psetq form is just like setq, except that multiple assignments are done in parallel rather than sequentially.

Macro: cl-psetq [symbol form]… ¶

    This special form (actually a macro) is used to assign to several variables simultaneously. Given only one symbol and form, it has the same effect as setq. Given several symbol and form pairs, it evaluates all the forms in advance and then stores the corresponding variables afterwards.

    (setq x 2 y 3)
    (setq x (+ x y)  y (* x y))
    x
         ⇒ 5
    y                     ; y was computed after x was set.
         ⇒ 15
    (setq x 2 y 3)
    (cl-psetq x (+ x y)  y (* x y))
    x
         ⇒ 5
    y                     ; y was computed before x was set.
         ⇒ 6

    The simplest use of cl-psetq is (cl-psetq x y y x), which exchanges the values of two variables. (The cl-rotatef form provides an even more convenient way to swap two variables; see Modify Macros.)

    cl-psetq always returns nil. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (car (cdr x))))


(defun cddar (x)
  "4.2 Generalized Variables

A generalized variable or place form is one of the many places in Lisp memory where values can be stored. The simplest place form is a regular Lisp variable. But the CARs and CDRs of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values are stored. For basic information, see Generalized Variables in GNU Emacs Lisp Reference Manual. This package provides several additional features related to generalized variables.

    Setf Extensions
    Modify Macros"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (cdr (car x))))

(defun cdddr (x)
  "4.2.1 Setf Extensions

Several standard (e.g., car) and Emacs-specific (e.g., window-point) Lisp functions are setf-able by default. This package defines setf handlers for several additional functions:

    Functions from this package:

    cl-rest        cl-subseq      cl-get         cl-getf
    cl-caaar…cl-cddddr          cl-first…cl-tenth

    Note that for cl-getf (as for nthcdr), the list argument of the function must itself be a valid place form.
    A macro call, in which case the macro is expanded and setf is applied to the resulting form. 

The setf macro takes care to evaluate all subforms in the proper left-to-right order; for example,

(setf (aref vec (cl-incf i)) i)

looks like it will evaluate (cl-incf i) exactly once, before the following access to i; the setf expander will insert temporary variables as necessary to ensure that it does in fact work this way no matter what setf-method is defined for aref. (In this case, aset would be used and no such steps would be necessary since aset takes its arguments in a convenient order.)

However, if the place form is a macro which explicitly evaluates its arguments in an unusual order, this unusual order will be preserved. Adapting an example from Steele, given

(defmacro wrong-order (x y) (list 'aref y x))

the form (setf (wrong-order a b) 17) will evaluate b first, then a, just as in an actual call to wrong-order. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (cdr (cdr x))))

(defun caaaar (x)
  "4.2.2 Modify Macros

This package defines a number of macros that operate on generalized variables. Many are interesting and useful even when the place is just a variable name.

Macro: cl-psetf [place form]… ¶

    This macro is to setf what cl-psetq is to setq: When several places and forms are involved, the assignments take place in parallel rather than sequentially. Specifically, all subforms are evaluated from left to right, then all the assignments are done (in an undefined order). 

Macro: cl-incf place &optional x ¶

    This macro increments the number stored in place by one, or by x if specified. The incremented value is returned. For example, (cl-incf i) is equivalent to (setq i (1+ i)), and (cl-incf (car x) 2) is equivalent to (setcar x (+ (car x) 2)).

    As with setf, care is taken to preserve the “apparent” order of evaluation. For example,

    (cl-incf (aref vec (cl-incf i)))

    appears to increment i once, then increment the element of vec addressed by i; this is indeed exactly what it does, which means the above form is not equivalent to the “obvious” expansion,

    (setf (aref vec (cl-incf i))
          (1+ (aref vec (cl-incf i))))   ; wrong!

    but rather to something more like

    (let ((temp (cl-incf i)))
      (setf (aref vec temp) (1+ (aref vec temp))))

    Again, all of this is taken care of automatically by cl-incf and the other generalized-variable macros.

    As a more Emacs-specific example of cl-incf, the expression (cl-incf (point) n) is essentially equivalent to (forward-char n). 

Macro: cl-decf place &optional x ¶

    This macro decrements the number stored in place by one, or by x if specified. 

Macro: cl-pushnew x place &key :test :test-not :key ¶

    This macro inserts x at the front of the list stored in place, but only if x isn’t present in the list already. The optional keyword arguments are interpreted in the same way as for cl-adjoin. See Lists as Sets. 

Macro: cl-shiftf place… newvalue ¶

    This macro shifts the places left by one, shifting in the value of newvalue (which may be any Lisp expression, not just a generalized variable), and returning the value shifted out of the first place. Thus, (cl-shiftf a b c d) is equivalent to

    (prog1
        a
      (cl-psetf a b
                b c
                c d))

    except that the subforms of a, b, and c are actually evaluated only once each and in the apparent order. 

Macro: cl-rotatef place… ¶

    This macro rotates the places left by one in circular fashion. Thus, (cl-rotatef a b c d) is equivalent to

    (cl-psetf a b
              b c
              c d
              d a)

    except for the evaluation of subforms. cl-rotatef always returns nil. Note that (cl-rotatef a b) conveniently exchanges a and b. 

The following macros were invented for this package; they have no analogues in Common Lisp.

Macro: cl-letf (bindings…) forms… ¶

    This macro is analogous to let, but for generalized variables rather than just symbols. Each binding should be of the form (place value); the original contents of the places are saved, the values are stored in them, and then the body forms are executed. Afterwards, the places are set back to their original saved contents. This cleanup happens even if the forms exit irregularly due to a throw or an error.

    For example,

    (cl-letf (((point) (point-min))
              (a 17))
         …)

    moves point in the current buffer to the beginning of the buffer, and also binds a to 17 (as if by a normal let, since a is just a regular variable). After the body exits, a is set back to its original value and point is moved back to its original position.

    Note that cl-letf on (point) is not quite like a save-excursion, as the latter effectively saves a marker which tracks insertions and deletions in the buffer. Actually, a cl-letf of (point-marker) is much closer to this behavior. (point and point-marker are equivalent as setf places; each will accept either an integer or a marker as the stored value.)

    Like in the case of let, the value forms are evaluated in the order they appear, but the order of bindings is unspecified. Therefore, avoid binding the same place more than once in a single cl-letf form.

    Since generalized variables look like lists, let’s shorthand of using ‘foo’ for ‘(foo nil)’ as a binding would be ambiguous in cl-letf and is not allowed.

    However, a binding specifier may be a one-element list ‘(place)’, which is similar to ‘(place place)’. In other words, the place is not disturbed on entry to the body, and the only effect of the cl-letf is to restore the original value of place afterwards.

    Note that in this case, and in fact almost every case, place must have a well-defined value outside the cl-letf body. There is essentially only one exception to this, which is place a plain variable with a specified value (such as (a 17) in the above example). 

Macro: cl-letf* (bindings…) forms… ¶

    This macro is to cl-letf what let* is to let: It does the bindings in sequential rather than parallel order. 

Macro: cl-callf function place args… ¶

    This is the “generic” modify macro. It calls function, which should be an unquoted function name, macro name, or lambda. It passes place and args as arguments, and assigns the result back to place. For example, (cl-incf place n) is the same as (cl-callf + place n). Some more examples:

    (cl-callf abs my-number)
    (cl-callf concat (buffer-name) "<" (number-to-string n) ">")
    (cl-callf cl-union happy-people (list joe bob) :test 'same-person)

    Note again that cl-callf is an extension to standard Common Lisp. 

Macro: cl-callf2 function arg1 place args… ¶

    This macro is like cl-callf, except that place is the second argument of function rather than the first. For example, (push x place) is equivalent to (cl-callf2 cons x place). 

The cl-callf and cl-callf2 macros serve as building blocks for other macros like cl-incf, and cl-pushnew. The cl-letf and cl-letf* macros are used in the processing of symbol macros; see Macro Bindings.

Macro: with-memoization place code… ¶

    This macro provides a simple way to do memoization. code is evaluated and then stashed in place. If place’s value is non-nil, return that value instead of evaluating code. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (car (car (car x)))))

(defun caaadr (x)
  "12.17 Generalized Variables

A generalized variable or place form is one of the many places in Lisp memory where values can be stored using the setf macro (see The setf Macro). The simplest place form is a regular Lisp variable. But the CARs and CDRs of lists, elements of arrays, properties of symbols, and many other locations are also places where Lisp values get stored.

Generalized variables are analogous to lvalues in the C language, where ‘x = a[i]’ gets an element from an array and ‘a[i] = x’ stores an element using the same notation. Just as certain forms like a[i] can be lvalues in C, there is a set of forms that can be generalized variables in Lisp.

    The setf Macro
    Defining new setf forms"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (car (car (cdr x)))))

(defun caadar (x)
  "(defun caadar (x)
  "Return the `car' of the `car' of the `cdr' of the `car' of X."
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (car (cdr (car x))))) "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (car (cdr (car x)))))

(defun caaddr (x)
  "12.17.2 Defining new setf forms

This section describes how to define new forms that setf can operate on.

Macro: gv-define-simple-setter name setter &optional fix-return ¶

    This macro enables you to easily define setf methods for simple cases. name is the name of a function, macro, or special form. You can use this macro whenever name has a directly corresponding setter function that updates it, e.g., (gv-define-simple-setter car setcar).

    This macro translates a call of the form

    (setf (name args…) value)

    into

    (setter args… value)

    Such a setf call is documented to return value. This is no problem with, e.g., car and setcar, because setcar returns the value that it set. If your setter function does not return value, use a non-nil value for the fix-return argument of gv-define-simple-setter. This expands into something equivalent to

    (let ((temp value))
      (setter args… temp)
      temp)

    so ensuring that it returns the correct result. 

Macro: gv-define-setter name arglist &rest body ¶

    This macro allows for more complex setf expansions than the previous form. You may need to use this form, for example, if there is no simple setter function to call, or if there is one but it requires different arguments to the place form.

    This macro expands the form (setf (name args…) value) by first binding the setf argument forms (value args…) according to arglist, and then executing body. body should return a Lisp form that does the assignment, and finally returns the value that was set. An example of using this macro is:

    (gv-define-setter caar (val x) `(setcar (car ,x) ,val))

Macro: gv-define-expander name handler ¶

    For more control over the expansion, the gv-define-expander macro can be used. For instance, a settable substring could be implemented this way:

    (gv-define-expander substring
      (lambda (do place from &optional to)
        (gv-letplace (getter setter) place
          (macroexp-let2* (from to)
            (funcall do `(substring ,getter ,from ,to)
                     (lambda (v)
                       (macroexp-let2* (v)
                         `(progn
                            ,(funcall setter `(cl--set-substring
                                               ,getter ,from ,to ,v))
                            ,v))))))))

Macro: gv-letplace (getter setter) place &rest body ¶

    The macro gv-letplace can be useful in defining macros that perform similarly to setf; for example, the incf macro of Common Lisp could be implemented this way:

    (defmacro incf (place &optional n)
      (gv-letplace (getter setter) place
        (macroexp-let2* ((v (or n 1)))
          (funcall setter `(+ ,v ,getter)))))

    getter will be bound to a copyable expression that returns the value of place. setter will be bound to a function that takes an expression v and returns a new expression that sets place to v. body should return a Emacs Lisp expression manipulating place via getter and setter. 

Consult the source file gv.el for more details.

Function: make-obsolete-generalized-variable obsolete-name current-name when ¶

    This function makes the byte compiler warn that the generalized variable obsolete-name is obsolete. If current-name is a symbol, then the warning message says to use current-name instead of obsolete-name. If current-name is a string, this is the message. when should be a string indicating when the variable was first made obsolete (usually a version number string). 

    Common Lisp note: Common Lisp defines another way to specify the setf behavior of a function, namely setf functions, whose names are lists (setf name) rather than symbols. For example, (defun (setf foo) …) defines the function that is used when setf is applied to foo. Emacs does not support this. It is a compile-time error to use setf on a form that has not already had an appropriate expansion defined. In Common Lisp, this is not an error since the function (setf func) might be defined later. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (car (cdr (cdr x)))))

(defun cadaar (x)
  "2.4.5 Sequence Types

A sequence is a Lisp object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp: lists and arrays.

Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.

Arrays are fixed-length sequences. They are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, whereas string elements must be characters, and bool-vector elements must be t or nil. Char-tables are like vectors except that they are indexed by any valid character code. The characters in a string can have text properties like characters in a buffer (see Text Properties), but vectors do not support text properties, even when their elements happen to be characters.

Lists, strings and the other array types also share important similarities. For example, all have a length l, and all have elements which can be indexed from zero to l minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function length reports the length of any kind of sequence. See Sequences, Arrays, and Vectors.

It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list () always stands for the same object, nil. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (car (car x)))))

(defun cadadr (x)
  "2.4.6 Cons Cell and List Types

A cons cell is an object that consists of two slots, called the CAR slot and the CDR slot. Each slot can hold any Lisp object. We also say that the CAR of this cons cell is whatever object its CAR slot currently holds, and likewise for the CDR.

A list is a series of cons cells, linked together so that the CDR slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol nil. See Lists, for details. Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a list structure.

    A note to C programmers: a Lisp list thus works as a linked list built up of cons cells. Because pointers in Lisp are implicit, we do not distinguish between a cons cell slot holding a value versus pointing to the value. 

Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called atoms.

The read syntax and printed representation for lists are identical, and consist of a left parenthesis, an arbitrary number of elements, and a right parenthesis. Here are examples of lists:

(A 2 "A")            ; A list of three elements.
()                   ; A list of no elements (the empty list).
nil                  ; A list of no elements (the empty list).
("A ()")             ; A list of one element: the string "A ()".
(A ())               ; A list of two elements: A and the empty list.
(A nil)              ; Equivalent to the previous.
((A B C))            ; A list of one element
                     ;   (which is a list of three elements).

Upon reading, each object inside the parentheses becomes an element of the list. That is, a cons cell is made for each element. The CAR slot of the cons cell holds the element, and its CDR slot refers to the next cons cell of the list, which holds the next element in the list. The CDR slot of the last cons cell is set to hold nil.

The names CAR and CDR derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; CAR was an instruction to extract the contents of the address part of a register, and CDR an instruction to extract the contents of the decrement. By contrast, cons cells are named for the function cons that creates them, which in turn was named for its purpose, the construction of cells.

    Drawing Lists as Box Diagrams
    Dotted Pair Notation
    Association List Type"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (car (cdr x)))))


(defun caddar (x)
  "2.4.6.1 Drawing Lists as Box Diagrams

A list can be illustrated by a diagram in which the cons cells are shown as pairs of boxes, like dominoes. (The Lisp reader cannot read such an illustration; unlike the textual notation, which can be understood by both humans and computers, the box illustrations can be understood only by humans.) This picture represents the three-element list (rose violet buttercup):

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup

In this diagram, each box represents a slot that can hold or refer to any Lisp object. Each pair of boxes represents a cons cell. Each arrow represents a reference to a Lisp object, either an atom or another cons cell.

In this example, the first box, which holds the CAR of the first cons cell, refers to or holds rose (a symbol). The second box, holding the CDR of the first cons cell, refers to the next pair of boxes, the second cons cell. The CAR of the second cons cell is violet, and its CDR is the third cons cell. The CDR of the third (and last) cons cell is nil.

Here is another diagram of the same list, (rose violet buttercup), sketched in a different manner:

 ---------------       ----------------       -------------------
| car   | cdr   |     | car    | cdr   |     | car       | cdr   |
| rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
|       |       |     |        |       |     |           |       |
 ---------------       ----------------       -------------------

A list with no elements in it is the empty list; it is identical to the symbol nil. In other words, nil is both a symbol and a list.

Here is the list (A ()), or equivalently (A nil), depicted with boxes and arrows:

    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> A        --> nil

Here is a more complex illustration, showing the three-element list, ((pine needles) oak maple), the first element of which is a two-element list:

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
     |             --> oak      --> maple
     |
     |     --- ---      --- ---
      --> |   |   |--> |   |   |--> nil
           --- ---      --- ---
            |            |
            |            |
             --> pine     --> needles

The same list represented in the second box notation looks like this:

 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   o   |   o------->| oak   |   o------->| maple |  nil |
|   |   |      |     |       |      |     |       |      |
 -- | ---------       --------------       --------------
    |
    |
    |        --------------       ----------------
    |       | car   | cdr  |     | car     | cdr  |
     ------>| pine  |   o------->| needles |  nil |
            |       |      |     |         |      |
             --------------       ----------------"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (cdr (car x)))))

(defun cadddr (x)
  "2.4.6.2 Dotted Pair Notation

Dotted pair notation is a general syntax for cons cells that represents the CAR and CDR explicitly. In this syntax, (a . b) stands for a cons cell whose CAR is the object a and whose CDR is the object b. Dotted pair notation is more general than list syntax because the CDR does not have to be a list. However, it is more cumbersome in cases where list syntax would work. In dotted pair notation, the list ‘(1 2 3)’ is written as ‘(1 . (2 . (3 . nil)))’. For nil-terminated lists, you can use either notation, but list notation is usually clearer and more convenient. When printing a list, the dotted pair notation is only used if the CDR of a cons cell is not a list.

Here’s an example using boxes to illustrate dotted pair notation. This example shows the pair (rose . violet):

    --- ---
   |   |   |--> violet
    --- ---
     |
     |
      --> rose

You can combine dotted pair notation with list notation to represent conveniently a chain of cons cells with a non-nil final CDR. You write a dot after the last element of the list, followed by the CDR of the final cons cell. For example, (rose violet . buttercup) is equivalent to (rose . (violet . buttercup)). The object looks like this:

    --- ---      --- ---
   |   |   |--> |   |   |--> buttercup
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet

The syntax (rose . violet . buttercup) is invalid because there is nothing that it could mean. If anything, it would say to put buttercup in the CDR of a cons cell whose CDR is already used for violet.

The list (rose violet) is equivalent to (rose . (violet)), and looks like this:

    --- ---      --- ---
   |   |   |--> |   |   |--> nil
    --- ---      --- ---
     |            |
     |            |
      --> rose     --> violet

Similarly, the three-element list (rose violet buttercup) is equivalent to (rose . (violet . (buttercup))). It looks like this:

    --- ---      --- ---      --- ---
   |   |   |--> |   |   |--> |   |   |--> nil
    --- ---      --- ---      --- ---
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (car (cdr (cdr (cdr x)))))


(defun cdaaar (x)
  "2.4.6.3 Association List Type

An association list or alist is a specially-constructed list whose elements are cons cells. In each element, the CAR is considered a key, and the CDR is considered an associated value. (In some cases, the associated value is stored in the CAR of the CDR.) Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.

For example,

(setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))

sets the variable alist-of-colors to an alist of three elements. In the first element, rose is the key and red is the value.

See Association Lists, for a further explanation of alists and for functions that work on alists. See Hash Tables, for another kind of lookup table, which is much faster for handling a large number of keys. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (car (car (car x)))))

(defun cdaadr (x)
  "5.8 Association Lists

An association list, or alist for short, records a mapping from keys to values. It is a list of cons cells called associations: the CAR of each cons cell is the key, and the CDR is the associated value.6

Here is an example of an alist. The key pine is associated with the value cones; the key oak is associated with acorns; and the key maple is associated with seeds.

((pine . cones)
 (oak . acorns)
 (maple . seeds))

Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol a is associated with the number 1, and the string "b" is associated with the list (2 3), which is the CDR of the alist element:

((a . 1) ("b" 2 3))

Sometimes it is better to design an alist to store the associated value in the CAR of the CDR of the element. Here is an example of such an alist:

((rose red) (lily white) (buttercup yellow))

Here we regard red as the value associated with rose. One advantage of this kind of alist is that you can store other related information—even a list of other items—in the CDR of the CDR. One disadvantage is that you cannot use rassq (see below) to find the element containing a given value. When neither of these considerations is important, the choice is a matter of taste, as long as you are consistent about it for any given alist.

The same alist shown above could be regarded as having the associated value in the CDR of the element; the value associated with rose would be the list (red).

Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.

In Emacs Lisp, it is not an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.

Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once. See Property Lists, for a comparison of property lists and association lists.

Function: assoc key alist &optional testfn ¶

    This function returns the first association for key in alist, comparing key against the alist elements using testfn if it is a function, and equal otherwise (see Equality Predicates). If testfn is a function, it is called with two arguments: the CAR of an element from alist and key. The function returns nil if no association in alist has a CAR equal to key, as tested by testfn. For example:

    (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
         ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
    (assoc 'oak trees)
         ⇒ (oak . acorns)
    (cdr (assoc 'oak trees))
         ⇒ acorns
    (assoc 'birch trees)
         ⇒ nil

    Here is another example, in which the keys and values are not symbols:

    (setq needles-per-cluster
          '((2 "Austrian Pine" "Red Pine")
            (3 "Pitch Pine")
            (5 "White Pine")))

    (cdr (assoc 3 needles-per-cluster))
         ⇒ ("Pitch Pine")
    (cdr (assoc 2 needles-per-cluster))
         ⇒ ("Austrian Pine" "Red Pine")

The function assoc-string is much like assoc except that it ignores certain differences between strings. See Comparison of Characters and Strings.

Function: rassoc value alist ¶

    This function returns the first association with value value in alist. It returns nil if no association in alist has a CDR equal to value.

    rassoc is like assoc except that it compares the CDR of each alist association instead of the CAR. You can think of this as reverse assoc, finding the key for a given value. 

Function: assq key alist ¶

    This function is like assoc in that it returns the first association for key in alist, but it makes the comparison using eq. assq returns nil if no association in alist has a CAR eq to key. This function is used more often than assoc, since eq is faster than equal and most alists use symbols as keys. See Equality Predicates.

    (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
         ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
    (assq 'pine trees)
         ⇒ (pine . cones)

    On the other hand, assq is not usually useful in alists where the keys may not be symbols:

    (setq leaves
          '(("simple leaves" . oak)
            ("compound leaves" . horsechestnut)))

    (assq "simple leaves" leaves)
         ⇒ Unspecified; might be nil or ("simple leaves" . oak).
    (assoc "simple leaves" leaves)
         ⇒ ("simple leaves" . oak)

Function: alist-get key alist &optional default remove testfn ¶

    This function is similar to assq. It finds the first association (key . value) by comparing key with alist elements, and, if found, returns the value of that association. If no association is found, the function returns default. Comparison of key against alist elements uses the function specified by testfn, defaulting to eq.

    This is a generalized variable (see Generalized Variables) that can be used to change a value with setf. When using it to set a value, optional argument remove non-nil means to remove key’s association from alist if the new value is eql to default. 

Function: rassq value alist ¶

    This function returns the first association with value value in alist. It returns nil if no association in alist has a CDR eq to value.

    rassq is like assq except that it compares the CDR of each alist association instead of the CAR. You can think of this as reverse assq, finding the key for a given value.

    For example:

    (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

    (rassq 'acorns trees)
         ⇒ (oak . acorns)
    (rassq 'spores trees)
         ⇒ nil

    rassq cannot search for a value stored in the CAR of the CDR of an element:

    (setq colors '((rose red) (lily white) (buttercup yellow)))

    (rassq 'white colors)
         ⇒ nil

    In this case, the CDR of the association (lily white) is not the symbol white, but rather the list (white). This becomes clearer if the association is written in dotted pair notation:

    (lily white) ≡ (lily . (white))

Function: assoc-default key alist &optional test default ¶

    This function searches alist for a match for key. For each element of alist, it compares the element (if it is an atom) or the element’s CAR (if it is a cons) against key, by calling test with two arguments: the element or its CAR, and key. The arguments are passed in that order so that you can get useful results using string-match with an alist that contains regular expressions (see Regular Expression Searching). If test is omitted or nil, equal is used for comparison.

    If an alist element matches key by this criterion, then assoc-default returns a value based on this element. If the element is a cons, then the value is the element’s CDR. Otherwise, the return value is default.

    If no alist element matches key, assoc-default returns nil. 

Function: copy-alist alist ¶

    This function returns a two-level deep copy of alist: it creates a new copy of each association, so that you can alter the associations of the new alist without changing the old one.

    (setq needles-per-cluster
          '((2 . ("Austrian Pine" "Red Pine"))
            (3 . ("Pitch Pine"))

            (5 . ("White Pine"))))
    ⇒
    ((2 "Austrian Pine" "Red Pine")
     (3 "Pitch Pine")
     (5 "White Pine"))

    (setq copy (copy-alist needles-per-cluster))
    ⇒
    ((2 "Austrian Pine" "Red Pine")
     (3 "Pitch Pine")
     (5 "White Pine"))

    (eq needles-per-cluster copy)
         ⇒ nil
    (equal needles-per-cluster copy)
         ⇒ t
    (eq (car needles-per-cluster) (car copy))
         ⇒ nil
    (cdr (car (cdr needles-per-cluster)))
         ⇒ ("Pitch Pine")

    (eq (cdr (car (cdr needles-per-cluster)))
        (cdr (car (cdr copy))))
         ⇒ t

    This example shows how copy-alist makes it possible to change the associations of one copy without affecting the other:

    (setcdr (assq 3 copy) '("Martian Vacuum Pine"))
    (cdr (assq 3 needles-per-cluster))
         ⇒ ("Pitch Pine")

Function: assq-delete-all key alist ¶

    This function deletes from alist all the elements whose CAR is eq to key, much as if you used delq to delete each such element one by one. It returns the shortened alist, and often modifies the original list structure of alist. For correct results, use the return value of assq-delete-all rather than looking at the saved value of alist.

    (setq alist (list '(foo 1) '(bar 2) '(foo 3) '(lose 4)))
         ⇒ ((foo 1) (bar 2) (foo 3) (lose 4))
    (assq-delete-all 'foo alist)
         ⇒ ((bar 2) (lose 4))
    alist
         ⇒ ((foo 1) (bar 2) (lose 4))

Function: assoc-delete-all key alist &optional test ¶

    This function is like assq-delete-all except that it accepts an optional argument test, a predicate function to compare the keys in alist. If omitted or nil, test defaults to equal. As assq-delete-all, this function often modifies the original list structure of alist. 

Function: rassq-delete-all value alist ¶

    This function deletes from alist all the elements whose CDR is eq to value. It returns the shortened alist, and often modifies the original list structure of alist. rassq-delete-all is like assq-delete-all except that it compares the CDR of each alist association instead of the CAR. 

Macro: let-alist alist body ¶

    Creates a binding for each symbol used as keys the association list alist, prefixed with dot. This can be useful when accessing several items in the same association list, and it’s best understood through a simple example:

    (setq colors '((rose . red) (lily . white) (buttercup . yellow)))
    (let-alist colors
      (if (eq .rose 'red)
          .lily))
         ⇒ white

    The body is inspected at compilation time, and only the symbols that appear in body with a ‘.’ as the first character in the symbol name will be bound. Finding the keys is done with assq, and the cdr of the return value of this assq is assigned as the value for the binding.

    Nested association lists is supported:

    (setq colors '((rose . red) (lily (belladonna . yellow) (brindisi . pink))))
    (let-alist colors
      (if (eq .rose 'red)
          .lily.belladonna))
         ⇒ yellow

    Nesting let-alist inside each other is allowed, but the code in the inner let-alist can’t access the variables bound by the outer let-alist. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (car (car (cdr x)))))

(defun cdadar (x)
  "5 Lists

A list represents a sequence of zero or more elements (which may be any Lisp objects). The important difference between lists and vectors is that two or more lists can share part of their structure; in addition, you can insert or delete elements in a list without copying the whole list.

    Lists and Cons Cells
    Predicates on Lists
    Accessing Elements of Lists
    Building Cons Cells and Lists
    Modifying List Variables
    Modifying Existing List Structure
    Using Lists as Sets
    Association Lists
    Property Lists"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (car (cdr (car x)))))

(defun cdaddr (x)
  "5.2 Predicates on Lists

The following predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object nil. (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)

Function: consp object ¶

    This function returns t if object is a cons cell, nil otherwise. nil is not a cons cell, although it is a list. 

Function: atom object ¶

    This function returns t if object is an atom, nil otherwise. All objects except cons cells are atoms. The symbol nil is an atom and is also a list; it is the only Lisp object that is both.

    (atom object) ≡ (not (consp object))

Function: listp object ¶

    This function returns t if object is a cons cell or nil. Otherwise, it returns nil.

    (listp '(1))
         ⇒ t

    (listp '())
         ⇒ t

Function: nlistp object ¶

    This function is the opposite of listp: it returns t if object is not a list. Otherwise, it returns nil.

    (listp object) ≡ (not (nlistp object))

Function: null object ¶

    This function returns t if object is nil, and returns nil otherwise. This function is identical to not, but as a matter of clarity we use null when object is considered a list and not when it is considered a truth value (see not in Constructs for Combining Conditions).

    (null '(1))
         ⇒ nil

    (null '())
         ⇒ t

Function: proper-list-p object ¶

    This function returns the length of object if it is a proper list, nil otherwise (see Lists and Cons Cells). In addition to satisfying listp, a proper list is neither circular nor dotted.

    (proper-list-p '(a b c))
        ⇒ 3

    (proper-list-p '(a b . c))
        ⇒ nil"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (car (cdr (cdr x)))))

(defun cddaar (x)
  "5.3 Accessing Elements of Lists

Function: car cons-cell ¶

    This function returns the value referred to by the first slot of the cons cell cons-cell. In other words, it returns the CAR of cons-cell.

    As a special case, if cons-cell is nil, this function returns nil. Therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or nil.

    (car '(a b c))
         ⇒ a

    (car '())
         ⇒ nil

Function: cdr cons-cell ¶

    This function returns the value referred to by the second slot of the cons cell cons-cell. In other words, it returns the CDR of cons-cell.

    As a special case, if cons-cell is nil, this function returns nil; therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or nil.

    (cdr '(a b c))
         ⇒ (b c)

    (cdr '())
         ⇒ nil

Function: car-safe object ¶

    This function lets you take the CAR of a cons cell while avoiding errors for other data types. It returns the CAR of object if object is a cons cell, nil otherwise. This is in contrast to car, which signals an error if object is not a list.

    (car-safe object)
    ≡
    (let ((x object))
      (if (consp x)
          (car x)
        nil))

Function: cdr-safe object ¶

    This function lets you take the CDR of a cons cell while avoiding errors for other data types. It returns the CDR of object if object is a cons cell, nil otherwise. This is in contrast to cdr, which signals an error if object is not a list.

    (cdr-safe object)
    ≡
    (let ((x object))
      (if (consp x)
          (cdr x)
        nil))

Macro: pop listname ¶

    This macro provides a convenient way to examine the CAR of a list, and take it off the list, all at once. It operates on the list stored in listname. It removes the first element from the list, saves the CDR into listname, then returns the removed element.

    In the simplest case, listname is an unquoted symbol naming a list; in that case, this macro is equivalent to (prog1 (car listname) (setq listname (cdr listname))).

    x
         ⇒ (a b c)
    (pop x)
         ⇒ a
    x
         ⇒ (b c)

    More generally, listname can be a generalized variable. In that case, this macro saves into listname using setf. See Generalized Variables.

    For the push macro, which adds an element to a list, See Modifying List Variables. 

Function: nth n list ¶

    This function returns the nth element of list. Elements are numbered starting with zero, so the CAR of list is element number zero. If the length of list is n or less, the value is nil.

    (nth 2 '(1 2 3 4))
         ⇒ 3

    (nth 10 '(1 2 3 4))
         ⇒ nil

    (nth n x) ≡ (car (nthcdr n x))

    The function elt is similar, but applies to any kind of sequence. For historical reasons, it takes its arguments in the opposite order. See Sequences. 

Function: nthcdr n list ¶

    This function returns the nth CDR of list. In other words, it skips past the first n links of list and returns what follows.

    If n is zero, nthcdr returns all of list. If the length of list is n or less, nthcdr returns nil.

    (nthcdr 1 '(1 2 3 4))
         ⇒ (2 3 4)

    (nthcdr 10 '(1 2 3 4))
         ⇒ nil

    (nthcdr 0 '(1 2 3 4))
         ⇒ (1 2 3 4)

Function: take n list ¶

    This function returns the n first elements of list. Essentially, it returns the part of list that nthcdr skips.

    take returns list if shorter than n elements; it returns nil if n is zero or negative.

    (take 3 '(a b c d))
         ⇒ (a b c)

    (take 10 '(a b c d))
         ⇒ (a b c d)

    (take 0 '(a b c d))
         ⇒ nil

Function: ntake n list ¶

    This is a version of take that works by destructively modifying the list structure of the argument. That makes it faster, but the original value of list may be lost.

    ntake returns list unmodified if shorter than n elements; it returns nil if n is zero or negative. Otherwise, it returns list truncated to its first n elements.

    This means that it is usually a good idea to use the return value and not just rely on the truncation effect unless n is known to be positive. 

Function: last list &optional n ¶

    This function returns the last link of list. The car of this link is the list’s last element. If list is null, nil is returned. If n is non-nil, the nth-to-last link is returned instead, or the whole of list if n is bigger than list’s length. 

Function: safe-length list ¶

    This function returns the length of list, with no risk of either an error or an infinite loop. It generally returns the number of distinct cons cells in the list. However, for circular lists, the value is just an upper bound; it is often too large.

    If list is not nil or a cons cell, safe-length returns 0. 

The most common way to compute the length of a list, when you are not worried that it may be circular, is with length. See Sequences.

Function: caar cons-cell ¶

    This is the same as (car (car cons-cell)). 

Function: cadr cons-cell ¶

    This is the same as (car (cdr cons-cell)) or (nth 1 cons-cell). 

Function: cdar cons-cell ¶

    This is the same as (cdr (car cons-cell)). 

Function: cddr cons-cell ¶

    This is the same as (cdr (cdr cons-cell)) or (nthcdr 2 cons-cell). 

In addition to the above, 24 additional compositions of car and cdr are defined as cxxxr and cxxxxr, where each x is either a or d. cadr, caddr, and cadddr pick out the second, third or fourth elements of a list, respectively. cl-lib provides the same under the names cl-second, cl-third, and cl-fourth. See List Functions in Common Lisp Extensions.

Function: butlast x &optional n ¶

    This function returns the list x with the last element, or the last n elements, removed. If n is greater than zero it makes a copy of the list so as not to damage the original list. In general, (append (butlast x n) (last x n)) will return a list equal to x. 

Function: nbutlast x &optional n ¶

    This is a version of butlast that works by destructively modifying the cdr of the appropriate element, rather than making a copy of the list. "
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (cdr (car (car x)))))

(defun cddadr (x)
  "5.4 Building Cons Cells and Lists

Many functions build lists, as lists reside at the very heart of Lisp. cons is the fundamental list-building function; however, it is interesting to note that list is used more times in the source code for Emacs than cons.

Function: cons object1 object2 ¶

    This function is the most basic function for building new list structure. It creates a new cons cell, making object1 the CAR, and object2 the CDR. It then returns the new cons cell. The arguments object1 and object2 may be any Lisp objects, but most often object2 is a list.

    (cons 1 '(2))
         ⇒ (1 2)

    (cons 1 '())
         ⇒ (1)

    (cons 1 2)
         ⇒ (1 . 2)

    cons is often used to add a single element to the front of a list. This is called consing the element onto the list. 5 For example:

    (setq list (cons newelt list))

    Note that there is no conflict between the variable named list used in this example and the function named list described below; any symbol can serve both purposes. 

Function: list &rest objects ¶

    This function creates a list with objects as its elements. The resulting list is always nil-terminated. If no objects are given, the empty list is returned.

    (list 1 2 3 4 5)
         ⇒ (1 2 3 4 5)

    (list 1 2 '(3 4 5) 'foo)
         ⇒ (1 2 (3 4 5) foo)

    (list)
         ⇒ nil

Function: make-list length object ¶

    This function creates a list of length elements, in which each element is object. Compare make-list with make-string (see Creating Strings).

    (make-list 3 'pigs)
         ⇒ (pigs pigs pigs)

    (make-list 0 'pigs)
         ⇒ nil

    (setq l (make-list 3 '(a b)))
         ⇒ ((a b) (a b) (a b))
    (eq (car l) (cadr l))
         ⇒ t

Function: append &rest sequences ¶

    This function returns a list containing all the elements of sequences. The sequences may be lists, vectors, bool-vectors, or strings, but the last one should usually be a list. All arguments except the last one are copied, so none of the arguments is altered. (See nconc in Functions that Rearrange Lists, for a way to join lists with no copying.)

    More generally, the final argument to append may be any Lisp object. The final argument is not copied or converted; it becomes the CDR of the last cons cell in the new list. If the final argument is itself a list, then its elements become in effect elements of the result list. If the final element is not a list, the result is a dotted list since its final CDR is not nil as required in a proper list (see Lists and Cons Cells). 

Here is an example of using append:

(setq trees '(pine oak))
     ⇒ (pine oak)
(setq more-trees (append '(maple birch) trees))
     ⇒ (maple birch pine oak)


trees
     ⇒ (pine oak)
more-trees
     ⇒ (maple birch pine oak)

(eq trees (cdr (cdr more-trees)))
     ⇒ t

You can see how append works by looking at a box diagram. The variable trees is set to the list (pine oak) and then the variable more-trees is set to the list (maple birch pine oak). However, the variable trees continues to refer to the original list:

more-trees                trees
|                           |
|     --- ---      --- ---   -> --- ---      --- ---
 --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
      --- ---      --- ---      --- ---      --- ---
       |            |            |            |
       |            |            |            |
        --> maple    -->birch     --> pine     --> oak

An empty sequence contributes nothing to the value returned by append. As a consequence of this, a final nil argument forces a copy of the previous argument:

trees
     ⇒ (pine oak)

(setq wood (append trees nil))
     ⇒ (pine oak)

wood
     ⇒ (pine oak)

(eq wood trees)
     ⇒ nil

This once was the usual way to copy a list, before the function copy-sequence was invented. See Sequences, Arrays, and Vectors.

Here we show the use of vectors and strings as arguments to append:

(append [a b] "cd" nil)
     ⇒ (a b 99 100)

With the help of apply (see Calling Functions), we can append all the lists in a list of lists:

(apply 'append '((a b c) nil (x y z) nil))
     ⇒ (a b c x y z)

If no sequences are given, nil is returned:

(append)
     ⇒ nil

Here are some examples where the final argument is not a list:

(append '(x y) 'z)
     ⇒ (x y . z)
(append '(x y) [z])
     ⇒ (x y . [z])

The second example shows that when the final argument is a sequence but not a list, the sequence’s elements do not become elements of the resulting list. Instead, the sequence becomes the final CDR, like any other non-list final argument.

Function: copy-tree tree &optional vecp ¶

    This function returns a copy of the tree tree. If tree is a cons cell, this makes a new cons cell with the same CAR and CDR, then recursively copies the CAR and CDR in the same way.

    Normally, when tree is anything other than a cons cell, copy-tree simply returns tree. However, if vecp is non-nil, it copies vectors too (and operates recursively on their elements). 

Function: flatten-tree tree ¶

    This function returns a “flattened” copy of tree, that is, a list containing all the non-nil terminal nodes, or leaves, of the tree of cons cells rooted at tree. Leaves in the returned list are in the same order as in tree. 

(flatten-tree '(1 (2 . 3) nil (4 5 (6)) 7))
    ⇒(1 2 3 4 5 6 7)

Function: ensure-list object ¶

    This function returns object as a list. If object is already a list, the function returns it; otherwise, the function returns a one-element list containing object.

    This is usually useful if you have a variable that may or may not be a list, and you can then say, for instance:

    (dolist (elem (ensure-list foo))
      (princ elem))

Function: number-sequence from &optional to separation ¶

    This function returns a list of numbers starting with from and incrementing by separation, and ending at or just before to. separation can be positive or negative and defaults to 1. If to is nil or numerically equal to from, the value is the one-element list (from). If to is less than from with a positive separation, or greater than from with a negative separation, the value is nil because those arguments specify an empty sequence.

    If separation is 0 and to is neither nil nor numerically equal to from, number-sequence signals an error, since those arguments specify an infinite sequence.

    All arguments are numbers. Floating-point arguments can be tricky, because floating-point arithmetic is inexact. For instance, depending on the machine, it may quite well happen that (number-sequence 0.4 0.6 0.2) returns the one element list (0.4), whereas (number-sequence 0.4 0.8 0.2) returns a list with three elements. The nth element of the list is computed by the exact formula (+ from (* n separation)). Thus, if one wants to make sure that to is included in the list, one can pass an expression of this exact type for to. Alternatively, one can replace to with a slightly larger value (or a slightly more negative value if separation is negative).

    Some examples:

    (number-sequence 4 9)
         ⇒ (4 5 6 7 8 9)
    (number-sequence 9 4 -1)
         ⇒ (9 8 7 6 5 4)
    (number-sequence 9 4 -2)
         ⇒ (9 7 5)
    (number-sequence 8)
         ⇒ (8)
    (number-sequence 8 5)
         ⇒ nil
    (number-sequence 5 8 -1)
         ⇒ nil
    (number-sequence 1.5 6 2)
         ⇒ (1.5 3.5 5.5)"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (cdr (car (cdr x)))))

(defun cdddar (x)
  "5.5 Modifying List Variables

These functions, and one macro, provide convenient ways to modify a list which is stored in a variable.

Macro: push element listname ¶

    This macro creates a new list whose CAR is element and whose CDR is the list specified by listname, and saves that list in listname. In the simplest case, listname is an unquoted symbol naming a list, and this macro is equivalent to (setq listname (cons element listname)).

    (setq l '(a b))
         ⇒ (a b)
    (push 'c l)
         ⇒ (c a b)
    l
         ⇒ (c a b)

    More generally, listname can be a generalized variable. In that case, this macro does the equivalent of (setf listname (cons element listname)). See Generalized Variables.

    For the pop macro, which removes the first element from a list, See Accessing Elements of Lists. 

Two functions modify lists that are the values of variables.

Function: add-to-list symbol element &optional append compare-fn ¶

    This function sets the variable symbol by consing element onto the old value, if element is not already a member of that value. It returns the resulting list, whether updated or not. The value of symbol had better be a list already before the call. add-to-list uses compare-fn to compare element against existing list members; if compare-fn is nil, it uses equal.

    Normally, if element is added, it is added to the front of symbol, but if the optional argument append is non-nil, it is added at the end.

    The argument symbol is not implicitly quoted; add-to-list is an ordinary function, like set and unlike setq. Quote the argument yourself if that is what you want.

    Do not use this function when symbol refers to a lexical variable. 

Here’s a scenario showing how to use add-to-list:

(setq foo '(a b))
     ⇒ (a b)

(add-to-list 'foo 'c)     ;; Add c.
     ⇒ (c a b)

(add-to-list 'foo 'b)     ;; No effect.
     ⇒ (c a b)

foo                       ;; foo was changed.
     ⇒ (c a b)

An equivalent expression for (add-to-list 'var value) is this:

(if (member value var)
    var
  (setq var (cons value var)))

Function: add-to-ordered-list symbol element &optional order ¶

    This function sets the variable symbol by inserting element into the old value, which must be a list, at the position specified by order. If element is already a member of the list, its position in the list is adjusted according to order. Membership is tested using eq. This function returns the resulting list, whether updated or not.

    The order is typically a number (integer or float), and the elements of the list are sorted in non-decreasing numerical order.

    order may also be omitted or nil. Then the numeric order of element stays unchanged if it already has one; otherwise, element has no numeric order. Elements without a numeric list order are placed at the end of the list, in no particular order.

    Any other value for order removes the numeric order of element if it already has one; otherwise, it is equivalent to nil.

    The argument symbol is not implicitly quoted; add-to-ordered-list is an ordinary function, like set and unlike setq. Quote the argument yourself if necessary.

    The ordering information is stored in a hash table on symbol’s list-order property. symbol cannot refer to a lexical variable. 

Here’s a scenario showing how to use add-to-ordered-list:

(setq foo '())
     ⇒ nil

(add-to-ordered-list 'foo 'a 1)     ;; Add a.
     ⇒ (a)

(add-to-ordered-list 'foo 'c 3)     ;; Add c.
     ⇒ (a c)

(add-to-ordered-list 'foo 'b 2)     ;; Add b.
     ⇒ (a b c)

(add-to-ordered-list 'foo 'b 4)     ;; Move b.
     ⇒ (a c b)

(add-to-ordered-list 'foo 'd)       ;; Append d.
     ⇒ (a c b d)

(add-to-ordered-list 'foo 'e)       ;; Add e.
     ⇒ (a c b e d)

foo                       ;; foo was changed.
     ⇒ (a c b e d)"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (cdr (cdr (car x)))))

(defun cddddr (x)
  "5.6 Modifying Existing List Structure

You can modify the CAR and CDR contents of a cons cell with the primitives setcar and setcdr. These are destructive operations because they change existing list structure. Destructive operations should be applied only to mutable lists, that is, lists constructed via cons, list or similar operations. Lists created by quoting are part of the program and should not be changed by destructive operations. See Mutability.

    Common Lisp note: Common Lisp uses functions rplaca and rplacd to alter list structure; they change structure the same way as setcar and setcdr, but the Common Lisp functions return the cons cell while setcar and setcdr return the new CAR or CDR. 

    Altering List Elements with setcar
    Altering the CDR of a List
    Functions that Rearrange Lists"
  (declare (compiler-macro internal--compiler-macro-cXXr))
  (cdr (cdr (cdr (cdr x)))))


(defun last (list &optional n)
  "5.6.1 Altering List Elements with setcar

Changing the CAR of a cons cell is done with setcar. When used on a list, setcar replaces one element of a list with a different element.

Function: setcar cons object ¶

    This function stores object as the new CAR of cons, replacing its previous CAR. In other words, it changes the CAR slot of cons to refer to object. It returns the value object. For example:

    (setq x (list 1 2))
         ⇒ (1 2)

    (setcar x 4)
         ⇒ 4

    x
         ⇒ (4 2)

When a cons cell is part of the shared structure of several lists, storing a new CAR into the cons changes one element of each of these lists. Here is an example:

;; Create two lists that are partly shared.
(setq x1 (list 'a 'b 'c))
     ⇒ (a b c)
(setq x2 (cons 'z (cdr x1)))
     ⇒ (z b c)


;; Replace the CAR of a shared link.
(setcar (cdr x1) 'foo)
     ⇒ foo
x1                           ; Both lists are changed.
     ⇒ (a foo c)
x2
     ⇒ (z foo c)


;; Replace the CAR of a link that is not shared.
(setcar x1 'baz)
     ⇒ baz
x1                           ; Only one list is changed.
     ⇒ (baz foo c)
x2
     ⇒ (z foo c)

Here is a graphical depiction of the shared structure of the two lists in the variables x1 and x2, showing why replacing b changes them both:

        --- ---        --- ---      --- ---
x1---> |   |   |----> |   |   |--> |   |   |--> nil
        --- ---        --- ---      --- ---
         |        -->   |            |
         |       |      |            |
          --> a  |       --> b        --> c
                 |
       --- ---   |
x2--> |   |   |--
       --- ---
        |
        |
         --> z

Here is an alternative form of box diagram, showing the same relationship:

x1:
 --------------       --------------       --------------
| car   | cdr  |     | car   | cdr  |     | car   | cdr  |
|   a   |   o------->|   b   |   o------->|   c   |  nil |
|       |      |  -->|       |      |     |       |      |
 --------------  |    --------------       --------------
                 |
x2:              |
 --------------  |
| car   | cdr  | |
|   z   |   o----
|       |      |
 --------------"
  (declare (side-effect-free t))
  (if n
      (and (>= n 0)
           (let ((m (safe-length list)))
             (if (< n m) (nthcdr (- m n) list) list)))
    (and list
         (nthcdr (1- (safe-length list)) list))))

(defun butlast (list &optional n)
  "5.6.2 Altering the CDR of a List

The lowest-level primitive for modifying a CDR is setcdr:

Function: setcdr cons object ¶

    This function stores object as the new CDR of cons, replacing its previous CDR. In other words, it changes the CDR slot of cons to refer to object. It returns the value object. 

Here is an example of replacing the CDR of a list with a different list. All but the first element of the list are removed in favor of a different sequence of elements. The first element is unchanged, because it resides in the CAR of the list, and is not reached via the CDR.

(setq x (list 1 2 3))
     ⇒ (1 2 3)

(setcdr x '(4))
     ⇒ (4)

x
     ⇒ (1 4)

You can delete elements from the middle of a list by altering the CDRs of the cons cells in the list. For example, here we delete the second element, b, from the list (a b c), by changing the CDR of the first cons cell:

(setq x1 (list 'a 'b 'c))
     ⇒ (a b c)
(setcdr x1 (cdr (cdr x1)))
     ⇒ (c)
x1
     ⇒ (a c)

Here is the result in box notation:

                   --------------------
                  |                    |
 --------------   |   --------------   |    --------------
| car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
|   a   |   o-----   |   b   |   o-------->|   c   |  nil |
|       |      |     |       |      |      |       |      |
 --------------       --------------        --------------

The second cons cell, which previously held the element b, still exists and its CAR is still b, but it no longer forms part of this list.

It is equally easy to insert a new element by changing CDRs:

(setq x1 (list 'a 'b 'c))
     ⇒ (a b c)
(setcdr x1 (cons 'd (cdr x1)))
     ⇒ (d b c)
x1
     ⇒ (a d b c)

Here is this result in box notation:

 --------------        -------------       -------------
| car  | cdr   |      | car  | cdr  |     | car  | cdr  |
|   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
|      |   |   |  |   |      |      |     |      |      |
 --------- | --   |    -------------       -------------
           |      |
     -----         --------
    |                      |
    |    ---------------   |
    |   | car   | cdr   |  |
     -->|   d   |   o------
        |       |       |
         ---------------"
  (declare (side-effect-free t))
  (if (and n (<= n 0)) list
    (nbutlast (copy-sequence list) n)))

(defun nbutlast (list &optional n)
  "5.6.3 Functions that Rearrange Lists

Here are some functions that rearrange lists destructively by modifying the CDRs of their component cons cells. These functions are destructive because they chew up the original lists passed to them as arguments, relinking their cons cells to form a new list that is the returned value.

See delq, in Using Lists as Sets, for another function that modifies cons cells.

Function: nconc &rest lists ¶

    This function returns a list containing all the elements of lists. Unlike append (see Building Cons Cells and Lists), the lists are not copied. Instead, the last CDR of each of the lists is changed to refer to the following list. The last of the lists is not altered. For example:

    (setq x (list 1 2 3))
         ⇒ (1 2 3)

    (nconc x '(4 5))
         ⇒ (1 2 3 4 5)

    x
         ⇒ (1 2 3 4 5)

    Since the last argument of nconc is not itself modified, it is reasonable to use a constant list, such as '(4 5), as in the above example. For the same reason, the last argument need not be a list:

    (setq x (list 1 2 3))
         ⇒ (1 2 3)

    (nconc x 'z)
         ⇒ (1 2 3 . z)

    x
         ⇒ (1 2 3 . z)

    However, the other arguments (all but the last) should be mutable lists.

    A common pitfall is to use a constant list as a non-last argument to nconc. If you do this, the resulting behavior is undefined (see Self-Evaluating Forms). It is possible that your program will change each time you run it! Here is what might happen (though this is not guaranteed to happen):

    (defun add-foo (x)            ; We want this function to add
      (nconc '(foo) x))           ;   foo to the front of its arg.


    (symbol-function 'add-foo)
         ⇒ (lambda (x) (nconc '(foo) x))


    (setq xx (add-foo '(1 2)))    ; It seems to work.
         ⇒ (foo 1 2)

    (setq xy (add-foo '(3 4)))    ; What happened?
         ⇒ (foo 1 2 3 4)

    (eq xx xy)
         ⇒ t


    (symbol-function 'add-foo)
         ⇒ (lambda (x) (nconc '(foo 1 2 3 4) x))"
  (let ((m (length list)))
    (or n (setq n 1))
    (and (< n m)
	 (progn
	   (if (> n 0) (setcdr (nthcdr (- (1- m) n) list) nil))
	   list))))

;; The function's definition was moved to fns.c,
;; but it's easier to set properties here.
(put 'proper-list-p 'pure t)
(put 'proper-list-p 'side-effect-free 'error-free)

(defun delete-dups (list)
  "2.4.8.3 Nonprinting Characters in Strings

You can use the same backslash escape-sequences in a string constant as in character literals (but do not use the question mark that begins a character constant). For example, you can write a string containing the nonprinting characters tab and C-a, with commas and spaces between them, like this: "\t, \C-a". See Character Type, for a description of the read syntax for characters.

However, not all of the characters you can write with backslash escape-sequences are valid in strings. The only control characters that a string can hold are the ASCII control characters. Strings do not distinguish case in ASCII control characters.

Properly speaking, strings cannot hold meta characters; but when a string is to be used as a key sequence, there is a special convention that provides a way to represent meta versions of ASCII characters in a string. If you use the ‘?\C-M’ syntax to indicate a meta character in a string constant, this sets the 2**7 bit of the character in the string. If the string is used in define-key or lookup-key, this numeric code is translated into the equivalent meta character. See Character Type.

Strings cannot hold characters that have the hyper, super, or alt modifiers. "
  (let ((l (length list)))
    (if (> l 100)
        (let ((hash (make-hash-table :test #'equal :size l))
              (tail list) retail)
          (puthash (car list) t hash)
          (while (setq retail (cdr tail))
            (let ((elt (car retail)))
              (if (gethash elt hash)
                  (setcdr tail (cdr retail))
                (puthash elt t hash)
                (setq tail retail)))))
      (let ((tail list))
        (while tail
          (setcdr tail (delete (car tail) (cdr tail)))
          (setq tail (cdr tail))))))
  list)


;; See https://lists.gnu.org/r/emacs-devel/2013-05/msg00204.html
(defun delete-consecutive-dups (list &optional circular)
  "2.4.8.4 Text Properties in Strings

A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text’s properties with no special effort. See Text Properties, for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:

#("characters" property-data...)

where property-data consists of zero or more elements, in groups of three as follows:

beg end plist

The elements beg and end are integers, and together specify a range of indices in the string; plist is the property list for that range. For example,

#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

represents a string whose textual contents are ‘foo bar’, in which the first three characters have a face property with value bold, and the last three have a face property with value italic. (The fourth character has no text properties, so its property list is nil. It is not actually necessary to mention ranges with nil as the property list, since any characters not mentioned in any range will default to having no properties.) "
  (let ((tail list) last)
    (while (cdr tail)
      (if (equal (car tail) (cadr tail))
	  (setcdr tail (cddr tail))
	(setq last tail
	      tail (cdr tail))))
    (if (and circular
	     last
	     (equal (car tail) (car list)))
	(setcdr last nil)))
  list)

(defun number-sequence (from &optional to inc)
  "2.4.9 Vector Type

A vector is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)

The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket. This is also the read syntax. Like numbers and strings, vectors are considered constants for evaluation.

[1 "two" (three)]      ; A vector of three elements.
     ⇒ [1 "two" (three)]

See Vectors, for functions that work with vectors. "
  (if (or (not to) (= from to))
      (list from)
    (or inc (setq inc 1))
    (when (zerop inc) (error "The increment can not be zero"))
    (let (seq (n 0) (next from))
      (if (> inc 0)
          (while (<= next to)
            (setq seq (cons next seq)
                  n (1+ n)
                  next (+ from (* n inc))))
        (while (>= next to)
          (setq seq (cons next seq)
                n (1+ n)
                next (+ from (* n inc)))))
      (nreverse seq))))

(defun copy-tree (tree &optional vecp)
  "2.4.9 Vector Type

A vector is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)

The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket. This is also the read syntax. Like numbers and strings, vectors are considered constants for evaluation.

[1 "two" (three)]      ; A vector of three elements.
     ⇒ [1 "two" (three)]

See Vectors, for functions that work with vectors. "
  (if (consp tree)
      (let (result)
	(while (consp tree)
	  (let ((newcar (car tree)))
	    (if (or (consp (car tree)) (and vecp (vectorp (car tree))))
		(setq newcar (copy-tree (car tree) vecp)))
	    (push newcar result))
	  (setq tree (cdr tree)))
	(nconc (nreverse result)
               (if (and vecp (vectorp tree)) (copy-tree tree vecp) tree)))
    (if (and vecp (vectorp tree))
	(let ((i (length (setq tree (copy-sequence tree)))))
	  (while (>= (setq i (1- i)) 0)
	    (aset tree i (copy-tree (aref tree i) vecp)))
	  tree)
      tree)))


;;;; Various list-search functions.

(defun assoc-default (key alist &optional test default)
  "2.4.10 Char-Table Type

A char-table is a one-dimensional array of elements of any type, indexed by character codes. Char-tables have certain extra features to make them more useful for many jobs that involve assigning information to character codes—for example, a char-table can have a parent to inherit from, a default value, and a small number of extra slots to use for special purposes. A char-table can also specify a single value for a whole character set.

The printed representation of a char-table is like a vector except that there is an extra ‘#^’ at the beginning.1

See Char-Tables, for special functions to operate on char-tables. Uses of char-tables include:

    Case tables (see The Case Table).
    Character category tables (see Categories).
    Display tables (see Display Tables).
    Syntax tables (see Syntax Tables). "
  (declare (side-effect-free t))
  (let (found (tail alist) value)
    (while (and tail (not found))
      (let ((elt (car tail)))
	(when (funcall (or test 'equal) (if (consp elt) (car elt) elt) key)
	  (setq found t value (if (consp elt) (cdr elt) default))))
      (setq tail (cdr tail)))
    value))

(defun member-ignore-case (elt list)
  "6.6 Char-Tables

A char-table is much like a vector, except that it is indexed by character codes. Any valid character code, without modifiers, can be used as an index in a char-table. You can access a char-table’s elements with aref and aset, as with any array. In addition, a char-table can have extra slots to hold additional data not associated with particular character codes. Like vectors, char-tables are constants when evaluated, and can hold elements of any type.

Each char-table has a subtype, a symbol, which serves two purposes:

    The subtype provides an easy way to tell what the char-table is for. For instance, display tables are char-tables with display-table as the subtype, and syntax tables are char-tables with syntax-table as the subtype. The subtype can be queried using the function char-table-subtype, described below.
    The subtype controls the number of extra slots in the char-table. This number is specified by the subtype’s char-table-extra-slots symbol property (see Symbol Properties), whose value should be an integer between 0 and 10. If the subtype has no such symbol property, the char-table has no extra slots. 

A char-table can have a parent, which is another char-table. If it does, then whenever the char-table specifies nil for a particular character c, it inherits the value specified in the parent. In other words, (aref char-table c) returns the value from the parent of char-table if char-table itself specifies nil.

A char-table can also have a default value. If so, then (aref char-table c) returns the default value whenever the char-table does not specify any other non-nil value.

Function: make-char-table subtype &optional init ¶

    Return a newly-created char-table, with subtype subtype (a symbol). Each element is initialized to init, which defaults to nil. You cannot alter the subtype of a char-table after the char-table is created.

    There is no argument to specify the length of the char-table, because all char-tables have room for any valid character code as an index.

    If subtype has the char-table-extra-slots symbol property, that specifies the number of extra slots in the char-table. This should be an integer between 0 and 10; otherwise, make-char-table raises an error. If subtype has no char-table-extra-slots symbol property (see Property Lists), the char-table has no extra slots. 

Function: char-table-p object ¶

    This function returns t if object is a char-table, and nil otherwise. 

Function: char-table-subtype char-table ¶

    This function returns the subtype symbol of char-table. 

There is no special function to access default values in a char-table. To do that, use char-table-range (see below).

Function: char-table-parent char-table ¶

    This function returns the parent of char-table. The parent is always either nil or another char-table. 

Function: set-char-table-parent char-table new-parent ¶

    This function sets the parent of char-table to new-parent. 

Function: char-table-extra-slot char-table n ¶

    This function returns the contents of extra slot n (zero based) of char-table. The number of extra slots in a char-table is determined by its subtype. 

Function: set-char-table-extra-slot char-table n value ¶

    This function stores value in extra slot n (zero based) of char-table. 

A char-table can specify an element value for a single character code; it can also specify a value for an entire character set.

Function: char-table-range char-table range ¶

    This returns the value specified in char-table for a range of characters range. Here are the possibilities for range:

    nil

        Refers to the default value.
    char

        Refers to the element for character char (supposing char is a valid character code).
    (from . to)

        A cons cell refers to all the characters in the inclusive range ‘[from..to]’. 

Function: set-char-table-range char-table range value ¶

    This function sets the value in char-table for a range of characters range. Here are the possibilities for range:

    nil

        Refers to the default value.
    t

        Refers to the whole range of character codes.
    char

        Refers to the element for character char (supposing char is a valid character code).
    (from . to)

        A cons cell refers to all the characters in the inclusive range ‘[from..to]’. 

Function: map-char-table function char-table ¶

    This function calls its argument function for each element of char-table that has a non-nil value. The call to function is with two arguments, a key and a value. The key is a possible range argument for char-table-range—either a valid character or a cons cell (from . to), specifying a range of characters that share the same value. The value is what (char-table-range char-table key) returns.

    Overall, the key-value pairs passed to function describe all the values stored in char-table.

    The return value is always nil; to make calls to map-char-table useful, function should have side effects. For example, here is how to examine the elements of the syntax table:

    (let (accumulator)
       (map-char-table
        (lambda (key value)
          (setq accumulator
                (cons (list
                       (if (consp key)
                           (list (car key) (cdr key))
                         key)
                       value)
                      accumulator)))
        (syntax-table))
       accumulator)
    ⇒
    (((2597602 4194303) (2)) ((2597523 2597601) (3))
     ... (65379 (5 . 65378)) (65378 (4 . 65379)) (65377 (1))
     ... (12 (0)) (11 (3)) (10 (12)) (9 (0)) ((0 8) (3)))

 "
  (declare (side-effect-free t))
  (while (and list
	      (not (and (stringp (car list))
			(eq t (compare-strings elt 0 nil (car list) 0 nil t)))))
    (setq list (cdr list)))
  list)


(defun assoc-delete-all (key alist &optional test)
  "9.4 Symbol Properties

A symbol may possess any number of symbol properties, which can be used to record miscellaneous information about the symbol. For example, when a symbol has a risky-local-variable property with a non-nil value, that means the variable which the symbol names is a risky file-local variable (see File Local Variables).

Each symbol’s properties and property values are stored in the symbol’s property list cell (see Symbol Components), in the form of a property list (see Property Lists).

    Accessing Symbol Properties
    Standard Symbol Properties"
  (unless test (setq test #'equal))
  (while (and (consp (car alist))
	      (funcall test (caar alist) key))
    (setq alist (cdr alist)))
  (let ((tail alist) tail-cdr)
    (while (setq tail-cdr (cdr tail))
      (if (and (consp (car tail-cdr))
	       (funcall test (caar tail-cdr) key))
	  (setcdr tail (cdr tail-cdr))
	(setq tail tail-cdr))))
  alist)

(defun assq-delete-all (key alist)
  "12.12 File Local Variables

A file can specify local variable values; Emacs uses these to create buffer-local bindings for those variables in the buffer visiting that file. See Local Variables in Files in The GNU Emacs Manual, for basic information about file-local variables. This section describes the functions and variables that affect how file-local variables are processed.

If a file-local variable could specify an arbitrary function or Lisp expression that would be called later, visiting a file could take over your Emacs. Emacs protects against this by automatically setting only those file-local variables whose specified values are known to be safe. Other file-local variables are set only if the user agrees.

For additional safety, read-circle is temporarily bound to nil when Emacs reads file-local variables (see Input Functions). This prevents the Lisp reader from recognizing circular and shared Lisp structures (see Read Syntax for Circular Objects).

User Option: enable-local-variables ¶

    This variable controls whether to process file-local variables. The possible values are:

    t (the default)

        Set the safe variables, and query (once) about any unsafe variables. 
    :safe

        Set only the safe variables and do not query. 
    :all

        Set all the variables and do not query. 
    nil

        Don’t set any variables. 
    anything else

        Query (once) about all the variables. 

Variable: inhibit-local-variables-regexps ¶

    This is a list of regular expressions. If a file has a name matching an element of this list, then it is not scanned for any form of file-local variable. For examples of why you might want to use this, see How Emacs Chooses a Major Mode. 

Variable: permanently-enabled-local-variables ¶

    Some local variable settings will, by default, be heeded even if enable-local-variables is nil. By default, this is only the case for the lexical-binding local variable setting, but this can be controlled by using this variable, which is a list of symbols. 

Function: hack-local-variables &optional handle-mode ¶

    This function parses, and binds or evaluates as appropriate, any local variables specified by the contents of the current buffer. The variable enable-local-variables has its effect here. However, this function does not look for the ‘mode:’ local variable in the ‘-*-’ line. set-auto-mode does that, also taking enable-local-variables into account (see How Emacs Chooses a Major Mode).

    This function works by walking the alist stored in file-local-variables-alist and applying each local variable in turn. It calls before-hack-local-variables-hook and hack-local-variables-hook before and after applying the variables, respectively. It only calls the before-hook if the alist is non-nil; it always calls the other hook. This function ignores a ‘mode’ element if it specifies the same major mode as the buffer already has.

    If the optional argument handle-mode is t, then all this function does is return a symbol specifying the major mode, if the ‘-*-’ line or the local variables list specifies one, and nil otherwise. It does not set the mode or any other file-local variable. If handle-mode has any value other than nil or t, any settings of ‘mode’ in the ‘-*-’ line or the local variables list are ignored, and the other settings are applied. If handle-mode is nil, all the file local variables are set. 

Variable: file-local-variables-alist ¶

    This buffer-local variable holds the alist of file-local variable settings. Each element of the alist is of the form (var . value), where var is a symbol of the local variable and value is its value. When Emacs visits a file, it first collects all the file-local variables into this alist, and then the hack-local-variables function applies them one by one. 

Variable: before-hack-local-variables-hook ¶

    Emacs calls this hook immediately before applying file-local variables stored in file-local-variables-alist. 

Variable: hack-local-variables-hook ¶

    Emacs calls this hook immediately after it finishes applying file-local variables stored in file-local-variables-alist. 

You can specify safe values for a variable with a safe-local-variable property. The property has to be a function of one argument; any value is safe if the function returns non-nil given that value. Many commonly-encountered file variables have safe-local-variable properties; these include fill-column, fill-prefix, and indent-tabs-mode. For boolean-valued variables that are safe, use booleanp as the property value.

If you want to define safe-local-variable properties for variables defined in C source code, add the names and the properties of those variables to the list in the “Safe local variables” section of files.el.

When defining a user option using defcustom, you can set its safe-local-variable property by adding the arguments :safe function to defcustom (see Defining Customization Variables). However, a safety predicate defined using :safe will only be known once the package that contains the defcustom is loaded, which is often too late. As an alternative, you can use the autoload cookie (see Autoload) to assign the option its safety predicate, like this:

;;;###autoload (put 'var 'safe-local-variable 'pred)

The safe value definitions specified with autoload are copied into the package’s autoloads file (loaddefs.el for most packages bundled with Emacs), and are known to Emacs since the beginning of a session.

User Option: safe-local-variable-values ¶

    This variable provides another way to mark some variable values as safe. It is a list of cons cells (var . val), where var is a variable name and val is a value which is safe for that variable.

    When Emacs asks the user whether or not to obey a set of file-local variable specifications, the user can choose to mark them as safe. Doing so adds those variable/value pairs to safe-local-variable-values, and saves it to the user’s custom file. 

User Option: ignored-local-variable-values ¶

    If there are some values of particular local variables that you always want to ignore completely, you can use this variable. Its value has the same form as safe-local-variable-values; a file-local variable setting to the value that appears in the list will always be ignored when processing the local variables specified by the file. As with that variable, when Emacs queries the user about whether to obey file-local variables, the user can choose to ignore their particular values permanently, and that will alter this variable and save it to the user’s custom file. Variable-value pairs that appear in this variable take precedence over the same pairs in safe-local-variable-values. 

Function: safe-local-variable-p sym val ¶

    This function returns non-nil if it is safe to give sym the value val, based on the above criteria. 

Some variables are considered risky. If a variable is risky, it is never entered automatically into safe-local-variable-values; Emacs always queries before setting a risky variable, unless the user explicitly allows a value by customizing safe-local-variable-values directly.

Any variable whose name has a non-nil risky-local-variable property is considered risky. When you define a user option using defcustom, you can set its risky-local-variable property by adding the arguments :risky value to defcustom (see Defining Customization Variables). In addition, any variable whose name ends in any of ‘-command’, ‘-frame-alist’, ‘-function’, ‘-functions’, ‘-hook’, ‘-hooks’, ‘-form’, ‘-forms’, ‘-map’, ‘-map-alist’, ‘-mode-alist’, ‘-program’, or ‘-predicate’ is automatically considered risky. The variables ‘font-lock-keywords’, ‘font-lock-keywords’ followed by a digit, and ‘font-lock-syntactic-keywords’ are also considered risky.

Function: risky-local-variable-p sym ¶

    This function returns non-nil if sym is a risky variable, based on the above criteria. 

Variable: ignored-local-variables ¶

    This variable holds a list of variables that should not be given local values by files. Any value specified for one of these variables is completely ignored. 

The ‘Eval:’ “variable” is also a potential loophole, so Emacs normally asks for confirmation before handling it.

User Option: enable-local-eval ¶

    This variable controls processing of ‘Eval:’ in ‘-*-’ lines or local variables lists in files being visited. A value of t means process them unconditionally; nil means ignore them; anything else means ask the user what to do for each file. The default value is maybe. 

User Option: safe-local-eval-forms ¶

    This variable holds a list of expressions that are safe to evaluate when found in the ‘Eval:’ “variable” in a file local variables list. 

If the expression is a function call and the function has a safe-local-eval-function property, the property value determines whether the expression is safe to evaluate. The property value can be a predicate to call to test the expression, a list of such predicates (it’s safe if any predicate succeeds), or t (always safe provided the arguments are constant).

Text properties are also potential loopholes, since their values could include functions to call. So Emacs discards all text properties from string values specified for file-local variables. "
  (assoc-delete-all key alist #'eq))

(defun rassq-delete-all (value alist)
  "2.6 Read Syntax for Circular Objects

To represent shared or circular structures within a complex of Lisp objects, you can use the reader constructs ‘#n=’ and ‘#n#’.

Use #n= before an object to label it for later reference; subsequently, you can use #n# to refer the same object in another place. Here, n is some integer. For example, here is how to make a list in which the first element recurs as the third element:

(#1=(a) b #1#)

This differs from ordinary syntax such as this

((a) b (a))

which would result in a list whose first and third elements look alike but are not the same Lisp object. This shows the difference:

(prog1 nil
  (setq x '(#1=(a) b #1#)))
(eq (nth 0 x) (nth 2 x))
     ⇒ t
(setq x '((a) b (a)))
(eq (nth 0 x) (nth 2 x))
     ⇒ nil

You can also use the same syntax to make a circular structure, which appears as an element within itself. Here is an example:

#1=(a #1#)

This makes a list whose second element is the list itself. Here’s how you can see that it really works:

(prog1 nil
  (setq x '#1=(a #1#)))
(eq x (cadr x))
     ⇒ t

The Lisp printer can produce this syntax to record circular and shared structure in a Lisp object, if you bind the variable print-circle to a non-nil value. See Variables Affecting Output. "
  (while (and (consp (car alist))
	      (eq (cdr (car alist)) value))
    (setq alist (cdr alist)))
  (let ((tail alist) tail-cdr)
    (while (setq tail-cdr (cdr tail))
      (if (and (consp (car tail-cdr))
	       (eq (cdr (car tail-cdr)) value))
	  (setcdr tail (cdr tail-cdr))
	(setq tail tail-cdr))))
  alist)

(defun alist-get (key alist &optional default remove testfn)
  "Find the first element of ALIST whose `car' equals KEY and return its `cdr'.
If KEY is not found in ALIST, return DEFAULT.
Equality with KEY is tested by TESTFN, defaulting to `eq'.

You can use `alist-get' in PLACE expressions.  This will modify
an existing association (more precisely, the first one if
multiple exist), or add a new element to the beginning of ALIST,
destructively modifying the list stored in ALIST.

Example:

   (setq foo \\='((a . 0)))
   (setf (alist-get \\='a foo) 1
         (alist-get \\='b foo) 2)

   foo => ((b . 2) (a . 1))


When using it to set a value, optional argument REMOVE non-nil
means to remove KEY from ALIST if the new value is `eql' to
DEFAULT (more precisely the first found association will be
deleted from the alist).

Example:

  (setq foo \\='((a . 1) (b . 2)))
  (setf (alist-get \\='b foo nil \\='remove) nil)

  foo => ((a . 1))"
  (ignore remove) ;;Silence byte-compiler.
  (let ((x (if (not testfn)
               (assq key alist)
             (assoc key alist testfn))))
    (if x (cdr x) default)))

(defun remove (elt seq)\
  "9.4.1 Accessing Symbol Properties

The following functions can be used to access symbol properties.

Function: get symbol property ¶

    This function returns the value of the property named property in symbol’s property list. If there is no such property, it returns nil. Thus, there is no distinction between a value of nil and the absence of the property.

    The name property is compared with the existing property names using eq, so any object is a legitimate property.

    See put for an example. 

Function: put symbol property value ¶

    This function puts value onto symbol’s property list under the property name property, replacing any previous property value. The put function returns value.

    (put 'fly 'verb 'transitive)
         ⇒'transitive
    (put 'fly 'noun '(a buzzing little bug))
         ⇒ (a buzzing little bug)
    (get 'fly 'verb)
         ⇒ transitive
    (symbol-plist 'fly)
         ⇒ (verb transitive noun (a buzzing little bug))

Function: symbol-plist symbol ¶

    This function returns the property list of symbol. 

Function: setplist symbol plist ¶

    This function sets symbol’s property list to plist. Normally, plist should be a well-formed property list, but this is not enforced. The return value is plist.

    (setplist 'foo '(a 1 b (2 3) c nil))
         ⇒ (a 1 b (2 3) c nil)
    (symbol-plist 'foo)
         ⇒ (a 1 b (2 3) c nil)

    For symbols in special obarrays, which are not used for ordinary purposes, it may make sense to use the property list cell in a nonstandard fashion; in fact, the abbrev mechanism does so (see Abbrevs and Abbrev Expansion).

    You could define put in terms of setplist and plist-put, as follows:

    (defun put (symbol prop value)
      (setplist symbol
                (plist-put (symbol-plist symbol) prop value)))

Function: function-get symbol property &optional autoload ¶

    This function is identical to get, except that if symbol is the name of a function alias, it looks in the property list of the symbol naming the actual function. See Defining Functions. If the optional argument autoload is non-nil, and symbol is auto-loaded, this function will try to autoload it, since autoloading might set property of symbol. If autoload is the symbol macro, only try autoloading if symbol is an auto-loaded macro. 

Function: function-put function property value ¶

    This function sets property of function to value. function should be a symbol. This function is preferred to calling put for setting properties of a function, because it will allow us some day to implement remapping of old properties to new ones. "
  (declare (side-effect-free t))
  (if (nlistp seq)
      ;; If SEQ isn't a list, there's no need to copy SEQ because
      ;; `delete' will return a new object.
      (delete elt seq)
    (delete elt (copy-sequence seq))))

(defun remq (elt list)
  "38 Abbrevs and Abbrev Expansion

An abbreviation or abbrev is a string of characters that may be expanded to a longer string. The user can insert the abbrev string and find it replaced automatically with the expansion of the abbrev. This saves typing.

The set of abbrevs currently in effect is recorded in an abbrev table. Each buffer has a local abbrev table, but normally all buffers in the same major mode share one abbrev table. There is also a global abbrev table. Normally both are used.

An abbrev table is represented as an obarray. See Creating and Interning Symbols, for information about obarrays. Each abbreviation is represented by a symbol in the obarray. The symbol’s name is the abbreviation; its value is the expansion; its function definition is the hook function for performing the expansion (see Defining Abbrevs); and its property list cell contains various additional properties, including the use count and the number of times the abbreviation has been expanded (see Abbrev Properties).

Certain abbrevs, called system abbrevs, are defined by a major mode instead of the user. A system abbrev is identified by its non-nil :system property (see Abbrev Properties). When abbrevs are saved to an abbrev file, system abbrevs are omitted. See Saving Abbrevs in Files.

Because the symbols used for abbrevs are not interned in the usual obarray, they will never appear as the result of reading a Lisp expression; in fact, normally they are never used except by the code that handles abbrevs. Therefore, it is safe to use them in a nonstandard way.

If the minor mode Abbrev mode is enabled, the buffer-local variable abbrev-mode is non-nil, and abbrevs are automatically expanded in the buffer. For the user-level commands for abbrevs, see Abbrev Mode in The GNU Emacs Manual.

    Abbrev Tables
    Defining Abbrevs
    Saving Abbrevs in Files
    Looking Up and Expanding Abbreviations
    Standard Abbrev Tables
    Abbrev Properties
    Abbrev Table Properties"
  (declare (side-effect-free t))
  (while (and (eq elt (car list)) (setq list (cdr list))))
  (if (memq elt list)
      (delq elt (copy-sequence list))
    list))


;;;; Keymap support.

(defun suppress-keymap (map &optional nodigits)
  "38.2 Defining Abbrevs

define-abbrev is the low-level basic function for defining an abbrev in an abbrev table.

When a major mode defines a system abbrev, it should call define-abbrev and specify t for the :system property. Be aware that any saved non-system abbrevs are restored at startup, i.e., before some major modes are loaded. Therefore, major modes should not assume that their abbrev tables are empty when they are first loaded.

Function: define-abbrev abbrev-table name expansion &optional hook &rest props ¶

    This function defines an abbrev named name, in abbrev-table, to expand to expansion and call hook, with properties props (see Abbrev Properties). The return value is name. The :system property in props is treated specially here: if it has the value force, then it will overwrite an existing definition even for a non-system abbrev of the same name.

    name should be a string. The argument expansion is normally the desired expansion (a string), or nil to undefine the abbrev. If it is anything but a string or nil, then the abbreviation expands solely by running hook.

    The argument hook is a function or nil. If hook is non-nil, then it is called with no arguments after the abbrev is replaced with expansion; point is located at the end of expansion when hook is called.

    If hook is a non-nil symbol whose no-self-insert property is non-nil, hook can explicitly control whether to insert the self-inserting input character that triggered the expansion. If hook returns non-nil in this case, that inhibits insertion of the character. By contrast, if hook returns nil, expand-abbrev (or abbrev-insert) also returns nil, as if expansion had not really occurred.

    Normally, define-abbrev sets the variable abbrevs-changed to t, if it actually changes the abbrev. This is so that some commands will offer to save the abbrevs. It does not do this for a system abbrev, since those aren’t saved anyway. 

User Option: only-global-abbrevs ¶

    If this variable is non-nil, it means that the user plans to use global abbrevs only. This tells the commands that define mode-specific abbrevs to define global ones instead. This variable does not alter the behavior of the functions in this section; it is examined by their callers. "
  (define-key map [remap self-insert-command] 'undefined)
  (or nodigits
      (let (loop)
	(define-key map "-" 'negative-argument)
	;; Make plain numbers do numeric args.
	(setq loop ?0)
	(while (<= loop ?9)
	  (define-key map (char-to-string loop) 'digit-argument)
	  (setq loop (1+ loop))))))

(defun make-composed-keymap (maps &optional parent)
  "38.1 Abbrev Tables

This section describes how to create and manipulate abbrev tables.

Function: make-abbrev-table &optional props ¶

    This function creates and returns a new, empty abbrev table—an obarray containing no symbols. It is a vector filled with zeros. props is a property list that is applied to the new table (see Abbrev Table Properties). 

Function: abbrev-table-p object ¶

    This function returns a non-nil value if object is an abbrev table. 

Function: clear-abbrev-table abbrev-table ¶

    This function undefines all the abbrevs in abbrev-table, leaving it empty. 

Function: copy-abbrev-table abbrev-table ¶

    This function returns a copy of abbrev-table—a new abbrev table containing the same abbrev definitions. It does not copy any property lists; only the names, values, and functions. 

Function: define-abbrev-table tabname definitions &optional docstring &rest props ¶

    This function defines tabname (a symbol) as an abbrev table name, i.e., as a variable whose value is an abbrev table. It defines abbrevs in the table according to definitions, a list of elements of the form (abbrevname expansion [hook] [props...]). These elements are passed as arguments to define-abbrev.

    The optional string docstring is the documentation string of the variable tabname. The property list props is applied to the abbrev table (see Abbrev Table Properties).

    If this function is called more than once for the same tabname, subsequent calls add the definitions in definitions to tabname, rather than overwriting the entire original contents. (A subsequent call only overrides abbrevs explicitly redefined or undefined in definitions.) 

Variable: abbrev-table-name-list ¶

    This is a list of symbols whose values are abbrev tables. define-abbrev-table adds the new abbrev table name to this list. 

Function: insert-abbrev-table-description name &optional human ¶

    This function inserts before point a description of the abbrev table named name. The argument name is a symbol whose value is an abbrev table.

    If human is non-nil, the description is human-oriented. System abbrevs are listed and identified as such. Otherwise the description is a Lisp expression—a call to define-abbrev-table that would define name as it is currently defined, but without the system abbrevs. (The mode or package using name is supposed to add these to name separately.) "
  `(keymap
    ,@(if (keymapp maps) (list maps) maps)
    ,@parent))

(defun define-key-after (keymap key definition &optional after)
  "38.7 Abbrev Table Properties

Like abbrevs, abbrev tables have properties, some of which influence the way they work. You can provide them as arguments to define-abbrev-table, and manipulate them with the functions:

Function: abbrev-table-put table prop val ¶

    Set the property prop of abbrev table table to value val. 

Function: abbrev-table-get table prop ¶

    Return the property prop of abbrev table table, or nil if table has no such property. 

The following properties have special meaning:

:enable-function

    This is like the :enable-function abbrev property except that it applies to all abbrevs in the table. It is used before even trying to find the abbrev before point, so it can dynamically modify the abbrev table.
:case-fixed

    This is like the :case-fixed abbrev property except that it applies to all abbrevs in the table.
:regexp

    If non-nil, this property is a regular expression that indicates how to extract the name of the abbrev before point, before looking it up in the table. When the regular expression matches before point, the abbrev name is expected to be in submatch 1. If this property is nil, the default is to use backward-word and forward-word to find the name. This property allows the use of abbrevs whose name contains characters of non-word syntax.
:parents

    This property holds a list of tables from which to inherit other abbrevs.
:abbrev-table-modiff

    This property holds a counter incremented each time a new abbrev is added to the table."
  (unless after (setq after t))
  (or (keymapp keymap)
      (signal 'wrong-type-argument (list 'keymapp keymap)))
  (setq key
	(if (<= (length key) 1) (aref key 0)
	  (setq keymap (lookup-key keymap
				   (apply 'vector
					  (butlast (mapcar 'identity key)))))
	  (aref key (1- (length key)))))
  (let ((tail keymap) done inserted)
    (while (and (not done) tail)
      ;; Delete any earlier bindings for the same key.
      (if (eq (car-safe (car (cdr tail))) key)
	  (setcdr tail (cdr (cdr tail))))
      ;; If we hit an included map, go down that one.
      (if (keymapp (car tail)) (setq tail (car tail)))
      ;; When we reach AFTER's binding, insert the new binding after.
      ;; If we reach an inherited keymap, insert just before that.
      ;; If we reach the end of this keymap, insert at the end.
      (if (or (and (eq (car-safe (car tail)) after)
		   (not (eq after t)))
	      (eq (car (cdr tail)) 'keymap)
	      (null (cdr tail)))
	  (progn
	    ;; Stop the scan only if we find a parent keymap.
	    ;; Keep going past the inserted element
	    ;; so we can delete any duplications that come later.
	    (if (eq (car (cdr tail)) 'keymap)
		(setq done t))
	    ;; Don't insert more than once.
	    (or inserted
		(setcdr tail (cons (cons key definition) (cdr tail))))
	    (setq inserted t)))
      (setq tail (cdr tail)))))


(defun map-keymap-sorted (function keymap)
  "38.5 Standard Abbrev Tables

Here we list the variables that hold the abbrev tables for the preloaded major modes of Emacs.

Variable: global-abbrev-table ¶

    This is the abbrev table for mode-independent abbrevs. The abbrevs defined in it apply to all buffers. Each buffer may also have a local abbrev table, whose abbrev definitions take precedence over those in the global table. 

Variable: local-abbrev-table ¶

    The value of this buffer-local variable is the (mode-specific) abbreviation table of the current buffer. It can also be a list of such tables. 

Variable: abbrev-minor-mode-table-alist ¶

    The value of this variable is a list of elements of the form (mode . abbrev-table) where mode is the name of a variable: if the variable is bound to a non-nil value, then the abbrev-table is active, otherwise it is ignored. abbrev-table can also be a list of abbrev tables. 

Variable: fundamental-mode-abbrev-table ¶

    This is the local abbrev table used in Fundamental mode; in other words, it is the local abbrev table in all buffers in Fundamental mode. 

Variable: text-mode-abbrev-table ¶

    This is the local abbrev table used in Text mode. 

Variable: lisp-mode-abbrev-table ¶

    This is the local abbrev table used in Lisp mode. It is the parent of the local abbrev table used in Emacs Lisp mode. See Abbrev Table Properties. "
  (let (list)
    (map-keymap (lambda (a b) (push (cons a b) list))
                keymap)
    (setq list (sort list
                     (lambda (a b)
                       (setq a (car a) b (car b))
                       (if (integerp a)
                           (if (integerp b) (< a b)
                             t)
                         (if (integerp b) t
                           ;; string< also accepts symbols.
                           (string< a b))))))
    (dolist (p list)
      (funcall function (car p) (cdr p)))))


(defun event-basic-type (event)
  "38.4 Looking Up and Expanding Abbreviations

Abbrevs are usually expanded by certain interactive commands, including self-insert-command. This section describes the subroutines used in writing such commands, as well as the variables they use for communication.

Function: abbrev-symbol abbrev &optional table ¶

    This function returns the symbol representing the abbrev named abbrev. It returns nil if that abbrev is not defined. The optional second argument table is the abbrev table in which to look it up. If table is nil, this function tries first the current buffer’s local abbrev table, and second the global abbrev table. 

Function: abbrev-expansion abbrev &optional table ¶

    This function returns the string that abbrev would expand into (as defined by the abbrev tables used for the current buffer). It returns nil if abbrev is not a valid abbrev. The optional argument table specifies the abbrev table to use, as in abbrev-symbol. 

Command: expand-abbrev ¶

    This command expands the abbrev before point, if any. If point does not follow an abbrev, this command does nothing. To do the expansion, it calls the function that is the value of the abbrev-expand-function variable, with no arguments, and returns whatever that function does.

    The default expansion function returns the abbrev symbol if it did expansion, and nil otherwise. If the abbrev symbol has a hook function that is a symbol whose no-self-insert property is non-nil, and if the hook function returns nil as its value, then the default expansion function returns nil, even though expansion did occur. 

Function: abbrev-insert abbrev &optional name start end ¶

    This function inserts the abbrev expansion of abbrev, replacing the text between start and end. If start is omitted, it defaults to point. name, if non-nil, should be the name by which this abbrev was found (a string); it is used to figure out whether to adjust the capitalization of the expansion. The function returns abbrev if the abbrev was successfully inserted, otherwise it returns nil. 

Command: abbrev-prefix-mark &optional arg ¶

    This command marks the current location of point as the beginning of an abbrev. The next call to expand-abbrev will use the text from here to point (where it is then) as the abbrev to expand, rather than using the previous word as usual.

    First, this command expands any abbrev before point, unless arg is non-nil. (Interactively, arg is the prefix argument.) Then it inserts a hyphen before point, to indicate the start of the next abbrev to be expanded. The actual expansion removes the hyphen. 

User Option: abbrev-all-caps ¶

    When this is set non-nil, an abbrev entered entirely in upper case is expanded using all upper case. Otherwise, an abbrev entered entirely in upper case is expanded by capitalizing each word of the expansion. 

Variable: abbrev-start-location ¶

    The value of this variable is a buffer position (an integer or a marker) for expand-abbrev to use as the start of the next abbrev to be expanded. The value can also be nil, which means to use the word before point instead. abbrev-start-location is set to nil each time expand-abbrev is called. This variable is also set by abbrev-prefix-mark. 

Variable: abbrev-start-location-buffer ¶

    The value of this variable is the buffer for which abbrev-start-location has been set. Trying to expand an abbrev in any other buffer clears abbrev-start-location. This variable is set by abbrev-prefix-mark. 

Variable: last-abbrev ¶

    This is the abbrev-symbol of the most recent abbrev expanded. This information is left by expand-abbrev for the sake of the unexpand-abbrev command (see Expanding Abbrevs in The GNU Emacs Manual). 

Variable: last-abbrev-location ¶

    This is the location of the most recent abbrev expanded. This contains information left by expand-abbrev for the sake of the unexpand-abbrev command. 

Variable: last-abbrev-text ¶

    This is the exact expansion text of the most recent abbrev expanded, after case conversion (if any). Its value is nil if the abbrev has already been unexpanded. This contains information left by expand-abbrev for the sake of the unexpand-abbrev command. 

Variable: abbrev-expand-function ¶

    The value of this variable is a function that expand-abbrev will call with no arguments to do the expansion. The function can do anything it wants before and after performing the expansion. It should return the abbrev symbol if expansion took place. 

The following sample code shows a simple use of abbrev-expand-function. It assumes that foo-mode is a mode for editing certain files in which lines that start with ‘#’ are comments. You want to use Text mode abbrevs for those lines. The regular local abbrev table, foo-mode-abbrev-table is appropriate for all other lines. See Standard Abbrev Tables, for the definitions of local-abbrev-table and text-mode-abbrev-table. See Advising Emacs Lisp Functions, for details of add-function.

(defun foo-mode-abbrev-expand-function (expand)
  (if (not (save-excursion (forward-line 0) (eq (char-after) ?#)))
      ;; Performs normal expansion.
      (funcall expand)
    ;; We're inside a comment: use the text-mode abbrevs.
    (let ((local-abbrev-table text-mode-abbrev-table))
      (funcall expand))))

(add-hook 'foo-mode-hook
          (lambda ()
            (add-function :around (local 'abbrev-expand-function)
                          #'foo-mode-abbrev-expand-function)))"
  (if (consp event)
      (setq event (car event)))
  (if (symbolp event)
      (car (get event 'event-symbol-elements))
    (let* ((base (logand event (1- ?\A-\^@)))
	   (uncontrolled (if (< base 32) (logior base 64) base)))
      ;; There are some numbers that are invalid characters and
      ;; cause `downcase' to get an error.
      (condition-case ()
	  (downcase uncontrolled)
	(error uncontrolled)))))

(defsubst mouse-movement-p (object)
  "13.12 Advising Emacs Lisp Functions

When you need to modify a function defined in another library, or when you need to modify a hook like foo-function, a process filter, or basically any variable or object field which holds a function value, you can use the appropriate setter function, such as fset or defun for named functions, setq for hook variables, or set-process-filter for process filters, but those are often too blunt, completely throwing away the previous value.

The advice feature lets you add to the existing definition of a function, by advising the function. This is a cleaner method than redefining the whole function.

Emacs’s advice system provides two sets of primitives for that: the core set, for function values held in variables and object fields (with the corresponding primitives being add-function and remove-function) and another set layered on top of it for named functions (with the main primitives being advice-add and advice-remove).

As a trivial example, here’s how to add advice that’ll modify the return value of a function every time it’s called:

(defun my-double (x)
  (* x 2))
(defun my-increase (x)
  (+ x 1))
(advice-add 'my-double :filter-return #'my-increase)

After adding this advice, if you call my-double with ‘3’, the return value will be ‘7’. To remove this advice, say

(advice-remove 'my-double #'my-increase)

A more advanced example would be to trace the calls to the process filter of a process proc:

(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter proc) #'my-tracing-function)

This will cause the process’s output to be passed to my-tracing-function before being passed to the original process filter. my-tracing-function receives the same arguments as the original function. When you’re done with it, you can revert to the untraced behavior with:

(remove-function (process-filter proc) #'my-tracing-function)

Similarly, if you want to trace the execution of the function named display-buffer, you could use:

(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)

Here, his-tracing-function is called instead of the original function and receives the original function (additionally to that function’s arguments) as argument, so it can call it if and when it needs to. When you’re tired of seeing this output, you can revert to the untraced behavior with:

(advice-remove 'display-buffer #'his-tracing-function)

The arguments :before and :around used in the above examples specify how the two functions are composed, since there are many different ways to do it. The added function is also called a piece of advice.

    Primitives to manipulate advices
    Advising Named Functions
    Ways to compose advice
    Adapting code using the old defadvice
    Advice and Byte Code"
  (eq (car-safe object) 'mouse-movement))

(defun mouse-event-p (object)
  "13.13 Declaring Functions Obsolete

You can mark a named function as obsolete, meaning that it may be removed at some point in the future. This causes Emacs to warn that the function is obsolete whenever it byte-compiles code containing that function, and whenever it displays the documentation for that function. In all other respects, an obsolete function behaves like any other function.

The easiest way to mark a function as obsolete is to put a (declare (obsolete …)) form in the function’s defun definition. See The declare Form. Alternatively, you can use the make-obsolete function, described below.

A macro (see Macros) can also be marked obsolete with make-obsolete; this has the same effects as for a function. An alias for a function or macro can also be marked as obsolete; this makes the alias itself obsolete, not the function or macro which it resolves to.

Function: make-obsolete obsolete-name current-name when ¶

    This function marks obsolete-name as obsolete. obsolete-name should be a symbol naming a function or macro, or an alias for a function or macro.

    If current-name is a symbol, the warning message says to use current-name instead of obsolete-name. current-name does not need to be an alias for obsolete-name; it can be a different function with similar functionality. current-name can also be a string, which serves as the warning message. The message should begin in lower case, and end with a period. It can also be nil, in which case the warning message provides no additional details.

    The argument when should be a string indicating when the function was first made obsolete—for example, a date or a release number. 

Macro: define-obsolete-function-alias obsolete-name current-name when &optional doc ¶

    This convenience macro marks the function obsolete-name obsolete and also defines it as an alias for the function current-name. It is equivalent to the following:

    (defalias obsolete-name current-name doc)
    (make-obsolete obsolete-name current-name when)

In addition, you can mark a particular calling convention for a function as obsolete:

Function: set-advertised-calling-convention function signature when ¶

    This function specifies the argument list signature as the correct way to call function. This causes the Emacs byte compiler to issue a warning whenever it comes across an Emacs Lisp program that calls function any other way (however, it will still allow the code to be byte compiled). when should be a string indicating when the variable was first made obsolete (usually a version number string).

    For instance, in old versions of Emacs the sit-for function accepted three arguments, like this

      (sit-for seconds milliseconds nodisp)

    However, calling sit-for this way is considered obsolete (see Waiting for Elapsed Time or Input). The old calling convention is deprecated like this:

    (set-advertised-calling-convention
      'sit-for '(seconds &optional nodisp) "22.1")

    The alternative to using this function is the advertised-calling-convention declare spec, see The declare Form. "
  ;; is this really correct? maybe remove mouse-movement?
      (memq (event-basic-type object) '(mouse-1 mouse-2 mouse-3 mouse-movement)))
